/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Channel,
  FeeRevenue,
  GenericTx,
  HTTPValidationError,
  Invoice,
  LightningInfoLite,
  LnInfo,
  NewAddressInput,
  OnChainTransaction,
  Payment,
  PaymentRequest,
  SendCoinsInput,
  SendCoinsResponse,
  UnlockWalletInput,
  WalletBalance,
} from '../models';
import {
    ChannelFromJSON,
    ChannelToJSON,
    FeeRevenueFromJSON,
    FeeRevenueToJSON,
    GenericTxFromJSON,
    GenericTxToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    InvoiceFromJSON,
    InvoiceToJSON,
    LightningInfoLiteFromJSON,
    LightningInfoLiteToJSON,
    LnInfoFromJSON,
    LnInfoToJSON,
    NewAddressInputFromJSON,
    NewAddressInputToJSON,
    OnChainTransactionFromJSON,
    OnChainTransactionToJSON,
    PaymentFromJSON,
    PaymentToJSON,
    PaymentRequestFromJSON,
    PaymentRequestToJSON,
    SendCoinsInputFromJSON,
    SendCoinsInputToJSON,
    SendCoinsResponseFromJSON,
    SendCoinsResponseToJSON,
    UnlockWalletInputFromJSON,
    UnlockWalletInputToJSON,
    WalletBalanceFromJSON,
    WalletBalanceToJSON,
} from '../models';

export interface LightningAddInvoiceLightningAddInvoicePostRequest {
    valueMsat: number;
    memo?: string;
    expiry?: number;
    isKeysend?: boolean;
}

export interface LightningCloseChannelLightningCloseChannelPostRequest {
    channelId: string;
    forceClose: boolean;
}

export interface LightningDecodePayReqLightningDecodePayReqGetRequest {
    payReq: string;
}

export interface LightningListAllTxLightningListAllTxGetRequest {
    successfulOnly?: boolean;
    indexOffset?: number;
    maxTx?: number;
    reversed?: boolean;
}

export interface LightningListInvoicesLightningListInvoicesGetRequest {
    pendingOnly?: boolean;
    indexOffset?: number;
    numMaxInvoices?: number;
    reversed?: boolean;
}

export interface LightningListPaymentsLightningListPaymentsGetRequest {
    includeIncomplete?: boolean;
    indexOffset?: number;
    maxPayments?: number;
    reversed?: boolean;
}

export interface LightningNewAddressLightningNewAddressPostRequest {
    newAddressInput: NewAddressInput;
}

export interface LightningOpenChannelLightningOpenChannelPostRequest {
    localFundingAmount: number;
    nodeURI: string;
    targetConfs?: number;
}

export interface LightningSendCoinsLightningSendCoinsPostRequest {
    sendCoinsInput: SendCoinsInput;
}

export interface LightningSendPaymentLightningSendPaymentPostRequest {
    payReq: string;
    timeoutSeconds?: number;
    feeLimitMsat?: number;
    amountMsat?: number;
}

export interface LightningUnlockWalletLightningUnlockWalletPostRequest {
    unlockWalletInput: UnlockWalletInput;
}

/**
 * 
 */
export class LightningApi extends runtime.BaseAPI {

    /**
     * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
     * Addinvoice adds a new Invoice to the database.
     */
    async lightningAddInvoiceLightningAddInvoicePostRaw(requestParameters: LightningAddInvoiceLightningAddInvoicePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Invoice>> {
        if (requestParameters.valueMsat === null || requestParameters.valueMsat === undefined) {
            throw new runtime.RequiredError('valueMsat','Required parameter requestParameters.valueMsat was null or undefined when calling lightningAddInvoiceLightningAddInvoicePost.');
        }

        const queryParameters: any = {};

        if (requestParameters.valueMsat !== undefined) {
            queryParameters['value_msat'] = requestParameters.valueMsat;
        }

        if (requestParameters.memo !== undefined) {
            queryParameters['memo'] = requestParameters.memo;
        }

        if (requestParameters.expiry !== undefined) {
            queryParameters['expiry'] = requestParameters.expiry;
        }

        if (requestParameters.isKeysend !== undefined) {
            queryParameters['is_keysend'] = requestParameters.isKeysend;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/add-invoice`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InvoiceFromJSON(jsonValue));
    }

    /**
     * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
     * Addinvoice adds a new Invoice to the database.
     */
    async lightningAddInvoiceLightningAddInvoicePost(requestParameters: LightningAddInvoiceLightningAddInvoicePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Invoice> {
        const response = await this.lightningAddInvoiceLightningAddInvoicePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For additional information see [LND docs](https://api.lightning.community/#closechannel)
     * close a channel
     */
    async lightningCloseChannelLightningCloseChannelPostRaw(requestParameters: LightningCloseChannelLightningCloseChannelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.channelId === null || requestParameters.channelId === undefined) {
            throw new runtime.RequiredError('channelId','Required parameter requestParameters.channelId was null or undefined when calling lightningCloseChannelLightningCloseChannelPost.');
        }

        if (requestParameters.forceClose === null || requestParameters.forceClose === undefined) {
            throw new runtime.RequiredError('forceClose','Required parameter requestParameters.forceClose was null or undefined when calling lightningCloseChannelLightningCloseChannelPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.channelId !== undefined) {
            queryParameters['channel_id'] = requestParameters.channelId;
        }

        if (requestParameters.forceClose !== undefined) {
            queryParameters['force_close'] = requestParameters.forceClose;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/close-channel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * For additional information see [LND docs](https://api.lightning.community/#closechannel)
     * close a channel
     */
    async lightningCloseChannelLightningCloseChannelPost(requestParameters: LightningCloseChannelLightningCloseChannelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.lightningCloseChannelLightningCloseChannelPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
     */
    async lightningDecodePayReqLightningDecodePayReqGetRaw(requestParameters: LightningDecodePayReqLightningDecodePayReqGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaymentRequest>> {
        if (requestParameters.payReq === null || requestParameters.payReq === undefined) {
            throw new runtime.RequiredError('payReq','Required parameter requestParameters.payReq was null or undefined when calling lightningDecodePayReqLightningDecodePayReqGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.payReq !== undefined) {
            queryParameters['pay_req'] = requestParameters.payReq;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/decode-pay-req`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentRequestFromJSON(jsonValue));
    }

    /**
     * DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
     */
    async lightningDecodePayReqLightningDecodePayReqGet(requestParameters: LightningDecodePayReqLightningDecodePayReqGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaymentRequest> {
        const response = await this.lightningDecodePayReqLightningDecodePayReqGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current on chain and channel balances of the lighting wallet.
     */
    async lightningGetBalanceLightningGetBalanceGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WalletBalance>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/get-balance`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WalletBalanceFromJSON(jsonValue));
    }

    /**
     * Get the current on chain and channel balances of the lighting wallet.
     */
    async lightningGetBalanceLightningGetBalanceGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WalletBalance> {
        const response = await this.lightningGetBalanceLightningGetBalanceGetRaw(initOverrides);
        return await response.value();
    }

    /**
     *  Currently, year and total fees are always null. Backends don\'t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
     * Returns the daily, weekly and monthly fee revenue earned.
     */
    async lightningGetFeeRevenueLightningGetFeeRevenueGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeeRevenue>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/get-fee-revenue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeeRevenueFromJSON(jsonValue));
    }

    /**
     *  Currently, year and total fees are always null. Backends don\'t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
     * Returns the daily, weekly and monthly fee revenue earned.
     */
    async lightningGetFeeRevenueLightningGetFeeRevenueGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeeRevenue> {
        const response = await this.lightningGetFeeRevenueLightningGetFeeRevenueGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Request information about the currently running lightning node.
     */
    async lightningGetInfoLightningGetInfoGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LnInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/get-info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnInfoFromJSON(jsonValue));
    }

    /**
     * Request information about the currently running lightning node.
     */
    async lightningGetInfoLightningGetInfoGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LnInfo> {
        const response = await this.lightningGetInfoLightningGetInfoGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get lightweight current lightning info. Less verbose version of /lightning/get-info
     */
    async lightningGetInfoLiteLightningGetInfoLiteGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LightningInfoLite>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/get-info-lite`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LightningInfoLiteFromJSON(jsonValue));
    }

    /**
     * Get lightweight current lightning info. Less verbose version of /lightning/get-info
     */
    async lightningGetInfoLiteLightningGetInfoLiteGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LightningInfoLite> {
        const response = await this.lightningGetInfoLiteLightningGetInfoLiteGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
     * Lists all on-chain transactions, payments and invoices in the wallet
     */
    async lightningListAllTxLightningListAllTxGetRaw(requestParameters: LightningListAllTxLightningListAllTxGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GenericTx>>> {
        const queryParameters: any = {};

        if (requestParameters.successfulOnly !== undefined) {
            queryParameters['successful_only'] = requestParameters.successfulOnly;
        }

        if (requestParameters.indexOffset !== undefined) {
            queryParameters['index_offset'] = requestParameters.indexOffset;
        }

        if (requestParameters.maxTx !== undefined) {
            queryParameters['max_tx'] = requestParameters.maxTx;
        }

        if (requestParameters.reversed !== undefined) {
            queryParameters['reversed'] = requestParameters.reversed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/list-all-tx`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GenericTxFromJSON));
    }

    /**
     * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
     * Lists all on-chain transactions, payments and invoices in the wallet
     */
    async lightningListAllTxLightningListAllTxGet(requestParameters: LightningListAllTxLightningListAllTxGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GenericTx>> {
        const response = await this.lightningListAllTxLightningListAllTxGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of open channels
     */
    async lightningListChannelsLightningListChannelsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Channel>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/list-channels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ChannelFromJSON));
    }

    /**
     * Returns a list of open channels
     */
    async lightningListChannelsLightningListChannelsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Channel>> {
        const response = await this.lightningListChannelsLightningListChannelsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all invoices from the wallet. Modeled after LND implementation.
     */
    async lightningListInvoicesLightningListInvoicesGetRaw(requestParameters: LightningListInvoicesLightningListInvoicesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Invoice>>> {
        const queryParameters: any = {};

        if (requestParameters.pendingOnly !== undefined) {
            queryParameters['pending_only'] = requestParameters.pendingOnly;
        }

        if (requestParameters.indexOffset !== undefined) {
            queryParameters['index_offset'] = requestParameters.indexOffset;
        }

        if (requestParameters.numMaxInvoices !== undefined) {
            queryParameters['num_max_invoices'] = requestParameters.numMaxInvoices;
        }

        if (requestParameters.reversed !== undefined) {
            queryParameters['reversed'] = requestParameters.reversed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/list-invoices`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvoiceFromJSON));
    }

    /**
     * Lists all invoices from the wallet. Modeled after LND implementation.
     */
    async lightningListInvoicesLightningListInvoicesGet(requestParameters: LightningListInvoicesLightningListInvoicesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Invoice>> {
        const response = await this.lightningListInvoicesLightningListInvoicesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all onchain transactions from the wallet
     */
    async lightningListOnchainTxLightningListOnchainTxGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OnChainTransaction>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/list-onchain-tx`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OnChainTransactionFromJSON));
    }

    /**
     * Lists all onchain transactions from the wallet
     */
    async lightningListOnchainTxLightningListOnchainTxGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OnChainTransaction>> {
        const response = await this.lightningListOnchainTxLightningListOnchainTxGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all outgoing payments. Modeled after LND implementation.
     */
    async lightningListPaymentsLightningListPaymentsGetRaw(requestParameters: LightningListPaymentsLightningListPaymentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Payment>>> {
        const queryParameters: any = {};

        if (requestParameters.includeIncomplete !== undefined) {
            queryParameters['include_incomplete'] = requestParameters.includeIncomplete;
        }

        if (requestParameters.indexOffset !== undefined) {
            queryParameters['index_offset'] = requestParameters.indexOffset;
        }

        if (requestParameters.maxPayments !== undefined) {
            queryParameters['max_payments'] = requestParameters.maxPayments;
        }

        if (requestParameters.reversed !== undefined) {
            queryParameters['reversed'] = requestParameters.reversed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/list-payments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PaymentFromJSON));
    }

    /**
     * Returns a list of all outgoing payments. Modeled after LND implementation.
     */
    async lightningListPaymentsLightningListPaymentsGet(requestParameters: LightningListPaymentsLightningListPaymentsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Payment>> {
        const response = await this.lightningListPaymentsLightningListPaymentsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
     * Generate a new on-chain address
     */
    async lightningNewAddressLightningNewAddressPostRaw(requestParameters: LightningNewAddressLightningNewAddressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.newAddressInput === null || requestParameters.newAddressInput === undefined) {
            throw new runtime.RequiredError('newAddressInput','Required parameter requestParameters.newAddressInput was null or undefined when calling lightningNewAddressLightningNewAddressPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/new-address`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewAddressInputToJSON(requestParameters.newAddressInput),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
     * Generate a new on-chain address
     */
    async lightningNewAddressLightningNewAddressPost(requestParameters: LightningNewAddressLightningNewAddressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.lightningNewAddressLightningNewAddressPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ ==1: interpreted as urgent (aim for next block) * Set _target_conf_ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ >=10: interpreted as slow (next 100 blocks or so)  > 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * open a new lightning channel
     */
    async lightningOpenChannelLightningOpenChannelPostRaw(requestParameters: LightningOpenChannelLightningOpenChannelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.localFundingAmount === null || requestParameters.localFundingAmount === undefined) {
            throw new runtime.RequiredError('localFundingAmount','Required parameter requestParameters.localFundingAmount was null or undefined when calling lightningOpenChannelLightningOpenChannelPost.');
        }

        if (requestParameters.nodeURI === null || requestParameters.nodeURI === undefined) {
            throw new runtime.RequiredError('nodeURI','Required parameter requestParameters.nodeURI was null or undefined when calling lightningOpenChannelLightningOpenChannelPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.localFundingAmount !== undefined) {
            queryParameters['local_funding_amount'] = requestParameters.localFundingAmount;
        }

        if (requestParameters.nodeURI !== undefined) {
            queryParameters['node_URI'] = requestParameters.nodeURI;
        }

        if (requestParameters.targetConfs !== undefined) {
            queryParameters['target_confs'] = requestParameters.targetConfs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/open-channel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ ==1: interpreted as urgent (aim for next block) * Set _target_conf_ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ >=10: interpreted as slow (next 100 blocks or so)  > 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * open a new lightning channel
     */
    async lightningOpenChannelLightningOpenChannelPost(requestParameters: LightningOpenChannelLightningOpenChannelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.lightningOpenChannelLightningOpenChannelPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  > 👉 See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ ==1: interpreted as urgent (aim for next block) * Set __target_conf__ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ >=10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  > 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * Attempt to send on-chain funds.
     */
    async lightningSendCoinsLightningSendCoinsPostRaw(requestParameters: LightningSendCoinsLightningSendCoinsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SendCoinsResponse>> {
        if (requestParameters.sendCoinsInput === null || requestParameters.sendCoinsInput === undefined) {
            throw new runtime.RequiredError('sendCoinsInput','Required parameter requestParameters.sendCoinsInput was null or undefined when calling lightningSendCoinsLightningSendCoinsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/send-coins`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SendCoinsInputToJSON(requestParameters.sendCoinsInput),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SendCoinsResponseFromJSON(jsonValue));
    }

    /**
     *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  > 👉 See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ ==1: interpreted as urgent (aim for next block) * Set __target_conf__ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ >=10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  > 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * Attempt to send on-chain funds.
     */
    async lightningSendCoinsLightningSendCoinsPost(requestParameters: LightningSendCoinsLightningSendCoinsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SendCoinsResponse> {
        const response = await this.lightningSendCoinsLightningSendCoinsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
     * Attempt to pay a payment request.
     */
    async lightningSendPaymentLightningSendPaymentPostRaw(requestParameters: LightningSendPaymentLightningSendPaymentPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Payment>> {
        if (requestParameters.payReq === null || requestParameters.payReq === undefined) {
            throw new runtime.RequiredError('payReq','Required parameter requestParameters.payReq was null or undefined when calling lightningSendPaymentLightningSendPaymentPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.payReq !== undefined) {
            queryParameters['pay_req'] = requestParameters.payReq;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeout_seconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.feeLimitMsat !== undefined) {
            queryParameters['fee_limit_msat'] = requestParameters.feeLimitMsat;
        }

        if (requestParameters.amountMsat !== undefined) {
            queryParameters['amount_msat'] = requestParameters.amountMsat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/send-payment`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentFromJSON(jsonValue));
    }

    /**
     *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
     * Attempt to pay a payment request.
     */
    async lightningSendPaymentLightningSendPaymentPost(requestParameters: LightningSendPaymentLightningSendPaymentPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Payment> {
        const response = await this.lightningSendPaymentLightningSendPaymentPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unlocks a locked wallet.
     */
    async lightningUnlockWalletLightningUnlockWalletPostRaw(requestParameters: LightningUnlockWalletLightningUnlockWalletPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.unlockWalletInput === null || requestParameters.unlockWalletInput === undefined) {
            throw new runtime.RequiredError('unlockWalletInput','Required parameter requestParameters.unlockWalletInput was null or undefined when calling lightningUnlockWalletLightningUnlockWalletPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWTBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/lightning/unlock-wallet`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnlockWalletInputToJSON(requestParameters.unlockWalletInput),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Unlocks a locked wallet.
     */
    async lightningUnlockWalletLightningUnlockWalletPost(requestParameters: LightningUnlockWalletLightningUnlockWalletPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.lightningUnlockWalletLightningUnlockWalletPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
