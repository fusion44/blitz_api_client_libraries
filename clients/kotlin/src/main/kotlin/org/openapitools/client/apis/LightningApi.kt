/**
 * FastAPI
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient

import org.openapitools.client.models.Channel
import org.openapitools.client.models.FeeRevenue
import org.openapitools.client.models.GenericTx
import org.openapitools.client.models.HTTPValidationError
import org.openapitools.client.models.Invoice
import org.openapitools.client.models.LightningInfoLite
import org.openapitools.client.models.LnInfo
import org.openapitools.client.models.NewAddressInput
import org.openapitools.client.models.OnChainTransaction
import org.openapitools.client.models.Payment
import org.openapitools.client.models.PaymentRequest
import org.openapitools.client.models.SendCoinsInput
import org.openapitools.client.models.SendCoinsResponse
import org.openapitools.client.models.UnlockWalletInput
import org.openapitools.client.models.WalletBalance

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class LightningApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Addinvoice adds a new Invoice to the database.
     * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
     * @param valueMsat 
     * @param memo  (optional, default to "")
     * @param expiry  (optional, default to 3600)
     * @param isKeysend  (optional, default to false)
     * @return Invoice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningAddInvoiceLightningAddInvoicePost(valueMsat: kotlin.Int, memo: kotlin.String? = "", expiry: kotlin.Int? = 3600, isKeysend: kotlin.Boolean? = false) : Invoice {
        val localVarResponse = lightningAddInvoiceLightningAddInvoicePostWithHttpInfo(valueMsat = valueMsat, memo = memo, expiry = expiry, isKeysend = isKeysend)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Invoice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Addinvoice adds a new Invoice to the database.
     * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
     * @param valueMsat 
     * @param memo  (optional, default to "")
     * @param expiry  (optional, default to 3600)
     * @param isKeysend  (optional, default to false)
     * @return ApiResponse<Invoice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningAddInvoiceLightningAddInvoicePostWithHttpInfo(valueMsat: kotlin.Int, memo: kotlin.String?, expiry: kotlin.Int?, isKeysend: kotlin.Boolean?) : ApiResponse<Invoice?> {
        val localVariableConfig = lightningAddInvoiceLightningAddInvoicePostRequestConfig(valueMsat = valueMsat, memo = memo, expiry = expiry, isKeysend = isKeysend)

        return request<Unit, Invoice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningAddInvoiceLightningAddInvoicePost
     *
     * @param valueMsat 
     * @param memo  (optional, default to "")
     * @param expiry  (optional, default to 3600)
     * @param isKeysend  (optional, default to false)
     * @return RequestConfig
     */
    fun lightningAddInvoiceLightningAddInvoicePostRequestConfig(valueMsat: kotlin.Int, memo: kotlin.String?, expiry: kotlin.Int?, isKeysend: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("value_msat", listOf(valueMsat.toString()))
                if (memo != null) {
                    put("memo", listOf(memo.toString()))
                }
                if (expiry != null) {
                    put("expiry", listOf(expiry.toString()))
                }
                if (isKeysend != null) {
                    put("is_keysend", listOf(isKeysend.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/lightning/add-invoice",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * close a channel
     * For additional information see [LND docs](https://api.lightning.community/#closechannel)
     * @param channelId 
     * @param forceClose 
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningCloseChannelLightningCloseChannelPost(channelId: kotlin.String, forceClose: kotlin.Boolean) : kotlin.String {
        val localVarResponse = lightningCloseChannelLightningCloseChannelPostWithHttpInfo(channelId = channelId, forceClose = forceClose)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * close a channel
     * For additional information see [LND docs](https://api.lightning.community/#closechannel)
     * @param channelId 
     * @param forceClose 
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningCloseChannelLightningCloseChannelPostWithHttpInfo(channelId: kotlin.String, forceClose: kotlin.Boolean) : ApiResponse<kotlin.String?> {
        val localVariableConfig = lightningCloseChannelLightningCloseChannelPostRequestConfig(channelId = channelId, forceClose = forceClose)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningCloseChannelLightningCloseChannelPost
     *
     * @param channelId 
     * @param forceClose 
     * @return RequestConfig
     */
    fun lightningCloseChannelLightningCloseChannelPostRequestConfig(channelId: kotlin.String, forceClose: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("channel_id", listOf(channelId.toString()))
                put("force_close", listOf(forceClose.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/lightning/close-channel",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
     * 
     * @param payReq The payment request string to be decoded
     * @return PaymentRequest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningDecodePayReqLightningDecodePayReqGet(payReq: kotlin.String) : PaymentRequest {
        val localVarResponse = lightningDecodePayReqLightningDecodePayReqGetWithHttpInfo(payReq = payReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
     * 
     * @param payReq The payment request string to be decoded
     * @return ApiResponse<PaymentRequest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningDecodePayReqLightningDecodePayReqGetWithHttpInfo(payReq: kotlin.String) : ApiResponse<PaymentRequest?> {
        val localVariableConfig = lightningDecodePayReqLightningDecodePayReqGetRequestConfig(payReq = payReq)

        return request<Unit, PaymentRequest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningDecodePayReqLightningDecodePayReqGet
     *
     * @param payReq The payment request string to be decoded
     * @return RequestConfig
     */
    fun lightningDecodePayReqLightningDecodePayReqGetRequestConfig(payReq: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("pay_req", listOf(payReq.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/decode-pay-req",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the current on chain and channel balances of the lighting wallet.
     * 
     * @return WalletBalance
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningGetBalanceLightningGetBalanceGet() : WalletBalance {
        val localVarResponse = lightningGetBalanceLightningGetBalanceGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WalletBalance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get the current on chain and channel balances of the lighting wallet.
     * 
     * @return ApiResponse<WalletBalance?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningGetBalanceLightningGetBalanceGetWithHttpInfo() : ApiResponse<WalletBalance?> {
        val localVariableConfig = lightningGetBalanceLightningGetBalanceGetRequestConfig()

        return request<Unit, WalletBalance>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningGetBalanceLightningGetBalanceGet
     *
     * @return RequestConfig
     */
    fun lightningGetBalanceLightningGetBalanceGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/get-balance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Returns the daily, weekly and monthly fee revenue earned.
     *  Currently, year and total fees are always null. Backends don&#39;t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
     * @return FeeRevenue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningGetFeeRevenueLightningGetFeeRevenueGet() : FeeRevenue {
        val localVarResponse = lightningGetFeeRevenueLightningGetFeeRevenueGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeeRevenue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Returns the daily, weekly and monthly fee revenue earned.
     *  Currently, year and total fees are always null. Backends don&#39;t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
     * @return ApiResponse<FeeRevenue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningGetFeeRevenueLightningGetFeeRevenueGetWithHttpInfo() : ApiResponse<FeeRevenue?> {
        val localVariableConfig = lightningGetFeeRevenueLightningGetFeeRevenueGetRequestConfig()

        return request<Unit, FeeRevenue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningGetFeeRevenueLightningGetFeeRevenueGet
     *
     * @return RequestConfig
     */
    fun lightningGetFeeRevenueLightningGetFeeRevenueGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/get-fee-revenue",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Request information about the currently running lightning node.
     * 
     * @return LnInfo
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningGetInfoLightningGetInfoGet() : LnInfo {
        val localVarResponse = lightningGetInfoLightningGetInfoGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LnInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Request information about the currently running lightning node.
     * 
     * @return ApiResponse<LnInfo?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningGetInfoLightningGetInfoGetWithHttpInfo() : ApiResponse<LnInfo?> {
        val localVariableConfig = lightningGetInfoLightningGetInfoGetRequestConfig()

        return request<Unit, LnInfo>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningGetInfoLightningGetInfoGet
     *
     * @return RequestConfig
     */
    fun lightningGetInfoLightningGetInfoGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/get-info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get lightweight current lightning info. Less verbose version of /lightning/get-info
     * 
     * @return LightningInfoLite
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningGetInfoLiteLightningGetInfoLiteGet() : LightningInfoLite {
        val localVarResponse = lightningGetInfoLiteLightningGetInfoLiteGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LightningInfoLite
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get lightweight current lightning info. Less verbose version of /lightning/get-info
     * 
     * @return ApiResponse<LightningInfoLite?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningGetInfoLiteLightningGetInfoLiteGetWithHttpInfo() : ApiResponse<LightningInfoLite?> {
        val localVariableConfig = lightningGetInfoLiteLightningGetInfoLiteGetRequestConfig()

        return request<Unit, LightningInfoLite>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningGetInfoLiteLightningGetInfoLiteGet
     *
     * @return RequestConfig
     */
    fun lightningGetInfoLiteLightningGetInfoLiteGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/get-info-lite",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Lists all on-chain transactions, payments and invoices in the wallet
     * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
     * @param successfulOnly If set, only successful transaction will be returned in the response. (optional, default to false)
     * @param indexOffset The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response. (optional, default to 0)
     * @param maxTx The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null. (optional, default to 0)
     * @param reversed If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. (optional, default to false)
     * @return kotlin.collections.List<GenericTx>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningListAllTxLightningListAllTxGet(successfulOnly: kotlin.Boolean? = false, indexOffset: kotlin.Int? = 0, maxTx: kotlin.Int? = 0, reversed: kotlin.Boolean? = false) : kotlin.collections.List<GenericTx> {
        val localVarResponse = lightningListAllTxLightningListAllTxGetWithHttpInfo(successfulOnly = successfulOnly, indexOffset = indexOffset, maxTx = maxTx, reversed = reversed)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<GenericTx>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Lists all on-chain transactions, payments and invoices in the wallet
     * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
     * @param successfulOnly If set, only successful transaction will be returned in the response. (optional, default to false)
     * @param indexOffset The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response. (optional, default to 0)
     * @param maxTx The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null. (optional, default to 0)
     * @param reversed If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<GenericTx>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningListAllTxLightningListAllTxGetWithHttpInfo(successfulOnly: kotlin.Boolean?, indexOffset: kotlin.Int?, maxTx: kotlin.Int?, reversed: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<GenericTx>?> {
        val localVariableConfig = lightningListAllTxLightningListAllTxGetRequestConfig(successfulOnly = successfulOnly, indexOffset = indexOffset, maxTx = maxTx, reversed = reversed)

        return request<Unit, kotlin.collections.List<GenericTx>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningListAllTxLightningListAllTxGet
     *
     * @param successfulOnly If set, only successful transaction will be returned in the response. (optional, default to false)
     * @param indexOffset The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response. (optional, default to 0)
     * @param maxTx The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null. (optional, default to 0)
     * @param reversed If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. (optional, default to false)
     * @return RequestConfig
     */
    fun lightningListAllTxLightningListAllTxGetRequestConfig(successfulOnly: kotlin.Boolean?, indexOffset: kotlin.Int?, maxTx: kotlin.Int?, reversed: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (successfulOnly != null) {
                    put("successful_only", listOf(successfulOnly.toString()))
                }
                if (indexOffset != null) {
                    put("index_offset", listOf(indexOffset.toString()))
                }
                if (maxTx != null) {
                    put("max_tx", listOf(maxTx.toString()))
                }
                if (reversed != null) {
                    put("reversed", listOf(reversed.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/list-all-tx",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Returns a list of open channels
     * 
     * @return kotlin.collections.List<Channel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningListChannelsLightningListChannelsGet() : kotlin.collections.List<Channel> {
        val localVarResponse = lightningListChannelsLightningListChannelsGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Channel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Returns a list of open channels
     * 
     * @return ApiResponse<kotlin.collections.List<Channel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningListChannelsLightningListChannelsGetWithHttpInfo() : ApiResponse<kotlin.collections.List<Channel>?> {
        val localVariableConfig = lightningListChannelsLightningListChannelsGetRequestConfig()

        return request<Unit, kotlin.collections.List<Channel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningListChannelsLightningListChannelsGet
     *
     * @return RequestConfig
     */
    fun lightningListChannelsLightningListChannelsGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/list-channels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Lists all invoices from the wallet. Modeled after LND implementation.
     * 
     * @param pendingOnly If set, only invoices that are not settled and not canceled will be returned in the response. (optional, default to false)
     * @param indexOffset The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response. (optional, default to 0)
     * @param numMaxInvoices The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null. (optional, default to 0)
     * @param reversed If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. (optional, default to false)
     * @return kotlin.collections.List<Invoice>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningListInvoicesLightningListInvoicesGet(pendingOnly: kotlin.Boolean? = false, indexOffset: kotlin.Int? = 0, numMaxInvoices: kotlin.Int? = 0, reversed: kotlin.Boolean? = false) : kotlin.collections.List<Invoice> {
        val localVarResponse = lightningListInvoicesLightningListInvoicesGetWithHttpInfo(pendingOnly = pendingOnly, indexOffset = indexOffset, numMaxInvoices = numMaxInvoices, reversed = reversed)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Invoice>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Lists all invoices from the wallet. Modeled after LND implementation.
     * 
     * @param pendingOnly If set, only invoices that are not settled and not canceled will be returned in the response. (optional, default to false)
     * @param indexOffset The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response. (optional, default to 0)
     * @param numMaxInvoices The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null. (optional, default to 0)
     * @param reversed If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<Invoice>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningListInvoicesLightningListInvoicesGetWithHttpInfo(pendingOnly: kotlin.Boolean?, indexOffset: kotlin.Int?, numMaxInvoices: kotlin.Int?, reversed: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<Invoice>?> {
        val localVariableConfig = lightningListInvoicesLightningListInvoicesGetRequestConfig(pendingOnly = pendingOnly, indexOffset = indexOffset, numMaxInvoices = numMaxInvoices, reversed = reversed)

        return request<Unit, kotlin.collections.List<Invoice>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningListInvoicesLightningListInvoicesGet
     *
     * @param pendingOnly If set, only invoices that are not settled and not canceled will be returned in the response. (optional, default to false)
     * @param indexOffset The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response. (optional, default to 0)
     * @param numMaxInvoices The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null. (optional, default to 0)
     * @param reversed If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. (optional, default to false)
     * @return RequestConfig
     */
    fun lightningListInvoicesLightningListInvoicesGetRequestConfig(pendingOnly: kotlin.Boolean?, indexOffset: kotlin.Int?, numMaxInvoices: kotlin.Int?, reversed: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pendingOnly != null) {
                    put("pending_only", listOf(pendingOnly.toString()))
                }
                if (indexOffset != null) {
                    put("index_offset", listOf(indexOffset.toString()))
                }
                if (numMaxInvoices != null) {
                    put("num_max_invoices", listOf(numMaxInvoices.toString()))
                }
                if (reversed != null) {
                    put("reversed", listOf(reversed.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/list-invoices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Lists all onchain transactions from the wallet
     * 
     * @return kotlin.collections.List<OnChainTransaction>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningListOnchainTxLightningListOnchainTxGet() : kotlin.collections.List<OnChainTransaction> {
        val localVarResponse = lightningListOnchainTxLightningListOnchainTxGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OnChainTransaction>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Lists all onchain transactions from the wallet
     * 
     * @return ApiResponse<kotlin.collections.List<OnChainTransaction>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningListOnchainTxLightningListOnchainTxGetWithHttpInfo() : ApiResponse<kotlin.collections.List<OnChainTransaction>?> {
        val localVariableConfig = lightningListOnchainTxLightningListOnchainTxGetRequestConfig()

        return request<Unit, kotlin.collections.List<OnChainTransaction>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningListOnchainTxLightningListOnchainTxGet
     *
     * @return RequestConfig
     */
    fun lightningListOnchainTxLightningListOnchainTxGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/list-onchain-tx",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Returns a list of all outgoing payments. Modeled after LND implementation.
     * 
     * @param includeIncomplete If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn&#39;t change the meaning of the indices, which are tied to individual payments. (optional, default to true)
     * @param indexOffset The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards. (optional, default to 0)
     * @param maxPayments The maximal number of payments returned in the response to this query. (optional, default to 0)
     * @param reversed If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order). (optional, default to false)
     * @return kotlin.collections.List<Payment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningListPaymentsLightningListPaymentsGet(includeIncomplete: kotlin.Boolean? = true, indexOffset: kotlin.Int? = 0, maxPayments: kotlin.Int? = 0, reversed: kotlin.Boolean? = false) : kotlin.collections.List<Payment> {
        val localVarResponse = lightningListPaymentsLightningListPaymentsGetWithHttpInfo(includeIncomplete = includeIncomplete, indexOffset = indexOffset, maxPayments = maxPayments, reversed = reversed)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Payment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Returns a list of all outgoing payments. Modeled after LND implementation.
     * 
     * @param includeIncomplete If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn&#39;t change the meaning of the indices, which are tied to individual payments. (optional, default to true)
     * @param indexOffset The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards. (optional, default to 0)
     * @param maxPayments The maximal number of payments returned in the response to this query. (optional, default to 0)
     * @param reversed If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order). (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<Payment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningListPaymentsLightningListPaymentsGetWithHttpInfo(includeIncomplete: kotlin.Boolean?, indexOffset: kotlin.Int?, maxPayments: kotlin.Int?, reversed: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<Payment>?> {
        val localVariableConfig = lightningListPaymentsLightningListPaymentsGetRequestConfig(includeIncomplete = includeIncomplete, indexOffset = indexOffset, maxPayments = maxPayments, reversed = reversed)

        return request<Unit, kotlin.collections.List<Payment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningListPaymentsLightningListPaymentsGet
     *
     * @param includeIncomplete If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn&#39;t change the meaning of the indices, which are tied to individual payments. (optional, default to true)
     * @param indexOffset The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards. (optional, default to 0)
     * @param maxPayments The maximal number of payments returned in the response to this query. (optional, default to 0)
     * @param reversed If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order). (optional, default to false)
     * @return RequestConfig
     */
    fun lightningListPaymentsLightningListPaymentsGetRequestConfig(includeIncomplete: kotlin.Boolean?, indexOffset: kotlin.Int?, maxPayments: kotlin.Int?, reversed: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeIncomplete != null) {
                    put("include_incomplete", listOf(includeIncomplete.toString()))
                }
                if (indexOffset != null) {
                    put("index_offset", listOf(indexOffset.toString()))
                }
                if (maxPayments != null) {
                    put("max_payments", listOf(maxPayments.toString()))
                }
                if (reversed != null) {
                    put("reversed", listOf(reversed.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/lightning/list-payments",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Generate a new on-chain address
     *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
     * @param newAddressInput 
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningNewAddressLightningNewAddressPost(newAddressInput: NewAddressInput) : kotlin.String {
        val localVarResponse = lightningNewAddressLightningNewAddressPostWithHttpInfo(newAddressInput = newAddressInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate a new on-chain address
     *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
     * @param newAddressInput 
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningNewAddressLightningNewAddressPostWithHttpInfo(newAddressInput: NewAddressInput) : ApiResponse<kotlin.String?> {
        val localVariableConfig = lightningNewAddressLightningNewAddressPostRequestConfig(newAddressInput = newAddressInput)

        return request<NewAddressInput, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningNewAddressLightningNewAddressPost
     *
     * @param newAddressInput 
     * @return RequestConfig
     */
    fun lightningNewAddressLightningNewAddressPostRequestConfig(newAddressInput: NewAddressInput) : RequestConfig<NewAddressInput> {
        val localVariableBody = newAddressInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/lightning/new-address",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * open a new lightning channel
     *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ &#x3D;&#x3D;1: interpreted as urgent (aim for next block) * Set _target_conf_ &gt;&#x3D;2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ &gt;&#x3D;10: interpreted as slow (next 100 blocks or so)  &gt; 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * @param localFundingAmount 
     * @param nodeURI 
     * @param targetConfs  (optional, default to 3)
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningOpenChannelLightningOpenChannelPost(localFundingAmount: kotlin.Int, nodeURI: kotlin.String, targetConfs: kotlin.Int? = 3) : kotlin.String {
        val localVarResponse = lightningOpenChannelLightningOpenChannelPostWithHttpInfo(localFundingAmount = localFundingAmount, nodeURI = nodeURI, targetConfs = targetConfs)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * open a new lightning channel
     *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ &#x3D;&#x3D;1: interpreted as urgent (aim for next block) * Set _target_conf_ &gt;&#x3D;2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ &gt;&#x3D;10: interpreted as slow (next 100 blocks or so)  &gt; 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * @param localFundingAmount 
     * @param nodeURI 
     * @param targetConfs  (optional, default to 3)
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningOpenChannelLightningOpenChannelPostWithHttpInfo(localFundingAmount: kotlin.Int, nodeURI: kotlin.String, targetConfs: kotlin.Int?) : ApiResponse<kotlin.String?> {
        val localVariableConfig = lightningOpenChannelLightningOpenChannelPostRequestConfig(localFundingAmount = localFundingAmount, nodeURI = nodeURI, targetConfs = targetConfs)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningOpenChannelLightningOpenChannelPost
     *
     * @param localFundingAmount 
     * @param nodeURI 
     * @param targetConfs  (optional, default to 3)
     * @return RequestConfig
     */
    fun lightningOpenChannelLightningOpenChannelPostRequestConfig(localFundingAmount: kotlin.Int, nodeURI: kotlin.String, targetConfs: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("local_funding_amount", listOf(localFundingAmount.toString()))
                put("node_URI", listOf(nodeURI.toString()))
                if (targetConfs != null) {
                    put("target_confs", listOf(targetConfs.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/lightning/open-channel",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Attempt to send on-chain funds.
     *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  &gt; 👉 See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ &#x3D;&#x3D;1: interpreted as urgent (aim for next block) * Set __target_conf__ &gt;&#x3D;2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ &gt;&#x3D;10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  &gt; 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * @param sendCoinsInput 
     * @return SendCoinsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningSendCoinsLightningSendCoinsPost(sendCoinsInput: SendCoinsInput) : SendCoinsResponse {
        val localVarResponse = lightningSendCoinsLightningSendCoinsPostWithHttpInfo(sendCoinsInput = sendCoinsInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SendCoinsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Attempt to send on-chain funds.
     *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  &gt; 👉 See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ &#x3D;&#x3D;1: interpreted as urgent (aim for next block) * Set __target_conf__ &gt;&#x3D;2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ &gt;&#x3D;10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  &gt; 👉 See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * @param sendCoinsInput 
     * @return ApiResponse<SendCoinsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningSendCoinsLightningSendCoinsPostWithHttpInfo(sendCoinsInput: SendCoinsInput) : ApiResponse<SendCoinsResponse?> {
        val localVariableConfig = lightningSendCoinsLightningSendCoinsPostRequestConfig(sendCoinsInput = sendCoinsInput)

        return request<SendCoinsInput, SendCoinsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningSendCoinsLightningSendCoinsPost
     *
     * @param sendCoinsInput 
     * @return RequestConfig
     */
    fun lightningSendCoinsLightningSendCoinsPostRequestConfig(sendCoinsInput: SendCoinsInput) : RequestConfig<SendCoinsInput> {
        val localVariableBody = sendCoinsInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/lightning/send-coins",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Attempt to pay a payment request.
     *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
     * @param payReq 
     * @param timeoutSeconds  (optional, default to 5)
     * @param feeLimitMsat  (optional, default to 8000)
     * @param amountMsat  (optional)
     * @return Payment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningSendPaymentLightningSendPaymentPost(payReq: kotlin.String, timeoutSeconds: kotlin.Int? = 5, feeLimitMsat: kotlin.Int? = 8000, amountMsat: kotlin.Int? = null) : Payment {
        val localVarResponse = lightningSendPaymentLightningSendPaymentPostWithHttpInfo(payReq = payReq, timeoutSeconds = timeoutSeconds, feeLimitMsat = feeLimitMsat, amountMsat = amountMsat)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Payment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Attempt to pay a payment request.
     *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
     * @param payReq 
     * @param timeoutSeconds  (optional, default to 5)
     * @param feeLimitMsat  (optional, default to 8000)
     * @param amountMsat  (optional)
     * @return ApiResponse<Payment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningSendPaymentLightningSendPaymentPostWithHttpInfo(payReq: kotlin.String, timeoutSeconds: kotlin.Int?, feeLimitMsat: kotlin.Int?, amountMsat: kotlin.Int?) : ApiResponse<Payment?> {
        val localVariableConfig = lightningSendPaymentLightningSendPaymentPostRequestConfig(payReq = payReq, timeoutSeconds = timeoutSeconds, feeLimitMsat = feeLimitMsat, amountMsat = amountMsat)

        return request<Unit, Payment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningSendPaymentLightningSendPaymentPost
     *
     * @param payReq 
     * @param timeoutSeconds  (optional, default to 5)
     * @param feeLimitMsat  (optional, default to 8000)
     * @param amountMsat  (optional)
     * @return RequestConfig
     */
    fun lightningSendPaymentLightningSendPaymentPostRequestConfig(payReq: kotlin.String, timeoutSeconds: kotlin.Int?, feeLimitMsat: kotlin.Int?, amountMsat: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("pay_req", listOf(payReq.toString()))
                if (timeoutSeconds != null) {
                    put("timeout_seconds", listOf(timeoutSeconds.toString()))
                }
                if (feeLimitMsat != null) {
                    put("fee_limit_msat", listOf(feeLimitMsat.toString()))
                }
                if (amountMsat != null) {
                    put("amount_msat", listOf(amountMsat.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/lightning/send-payment",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Unlocks a locked wallet.
     * 
     * @param unlockWalletInput 
     * @return kotlin.Boolean
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightningUnlockWalletLightningUnlockWalletPost(unlockWalletInput: UnlockWalletInput) : kotlin.Boolean {
        val localVarResponse = lightningUnlockWalletLightningUnlockWalletPostWithHttpInfo(unlockWalletInput = unlockWalletInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Boolean
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unlocks a locked wallet.
     * 
     * @param unlockWalletInput 
     * @return ApiResponse<kotlin.Boolean?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightningUnlockWalletLightningUnlockWalletPostWithHttpInfo(unlockWalletInput: UnlockWalletInput) : ApiResponse<kotlin.Boolean?> {
        val localVariableConfig = lightningUnlockWalletLightningUnlockWalletPostRequestConfig(unlockWalletInput = unlockWalletInput)

        return request<UnlockWalletInput, kotlin.Boolean>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightningUnlockWalletLightningUnlockWalletPost
     *
     * @param unlockWalletInput 
     * @return RequestConfig
     */
    fun lightningUnlockWalletLightningUnlockWalletPostRequestConfig(unlockWalletInput: UnlockWalletInput) : RequestConfig<UnlockWalletInput> {
        val localVariableBody = unlockWalletInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/lightning/unlock-wallet",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
