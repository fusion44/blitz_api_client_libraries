/**
 * FastAPI
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models

import org.openapitools.client.models.FeaturesEntry
import org.openapitools.client.models.InvoiceHTLC
import org.openapitools.client.models.InvoiceState
import org.openapitools.client.models.RouteHint

import com.squareup.moshi.Json

/**
 * 
 *
 * @param valueMsat The value of this invoice in milli satoshis.
 * @param addIndex  The index of this invoice. Each newly created invoice will increment this index making it monotonically increasing. CLN and LND handle ids differently. LND will generate an auto incremented integer id, while CLN will use a user supplied string id. To unify both, we auto generate an id for CLN and use the add_index for LND.  For `LND` this will be an `integer` in string form. This is auto generated by LND.  For `CLN` this will be a `string`. If the invoice was generated by BlitzAPI, this will be a [Firebase-like PushID](https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68). If generated by some other method, it'll be the string supplied by the user at the time of creation of the invoice. 
 * @param state The state the invoice is in.
 * @param memo Optional memo to attach along with the invoice. Used for record keeping purposes for the invoice's creator,         and will also be set in the description field of the encoded payment request if the description_hash field is not being used.
 * @param rPreimage The hex-encoded preimage(32 byte) which will allow settling an incoming HTLC payable to this preimage.
 * @param rHash The hash of the preimage.
 * @param settled Whether this invoice has been fulfilled
 * @param creationDate When this invoice was created. Not available with CLN.
 * @param settleDate When this invoice was settled. Not available with pending invoices.
 * @param expiryDate The time at which this invoice expires
 * @param paymentRequest A bare-bones invoice for a payment within the     Lightning Network. With the details of the invoice, the sender has all the data necessary to     send a payment to the recipient.     
 * @param descriptionHash      Hash(SHA-256) of a description of the payment. Used if the description of payment(memo) is too     long to naturally fit within the description field of an encoded payment request.     
 * @param expiry Payment request expiry time in seconds. Default is 3600 (1 hour).
 * @param fallbackAddr Fallback on-chain address.
 * @param cltvExpiry Delta to use for the time-lock of the CLTV extended to the final hop.
 * @param routeHints      Route hints that can each be individually used to assist in reaching the invoice's destination.     
 * @param `private` Whether this invoice should include routing hints for private channels.
 * @param settleIndex          The \"settle\" index of this invoice. Each newly settled invoice will  increment this index making it monotonically increasing.     
 * @param amtPaidSat      The amount that was accepted for this invoice, in satoshis. This     will ONLY be set if this invoice has been settled. We provide     this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted.     Additionally, it's possible that the sender paid MORE that     was specified in the original invoice. So we'll record that here as well.     
 * @param amtPaidMsat      The amount that was accepted for this invoice, in millisatoshis.     This will ONLY be set if this invoice has been settled. We     provide this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted. Additionally,     it's possible that the sender paid MORE that was specified in the     original invoice. So we'll record that here as well.     
 * @param htlcs List of HTLCs paying to this invoice[EXPERIMENTAL].
 * @param features List of features advertised on the invoice.
 * @param isKeysend [LND only] Indicates if this invoice was a spontaneous payment that arrived via keysend[EXPERIMENTAL].
 * @param paymentAddr  The payment address of this invoice. This value will be used in MPP payments,     and also for newer invoices that always require the MPP payload for added end-to-end security.
 * @param isAmp Signals whether or not this is an AMP invoice.
 */

data class Invoice (

    /* The value of this invoice in milli satoshis. */
    @Json(name = "value_msat")
    val valueMsat: kotlin.Int,

    /*  The index of this invoice. Each newly created invoice will increment this index making it monotonically increasing. CLN and LND handle ids differently. LND will generate an auto incremented integer id, while CLN will use a user supplied string id. To unify both, we auto generate an id for CLN and use the add_index for LND.  For `LND` this will be an `integer` in string form. This is auto generated by LND.  For `CLN` this will be a `string`. If the invoice was generated by BlitzAPI, this will be a [Firebase-like PushID](https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68). If generated by some other method, it'll be the string supplied by the user at the time of creation of the invoice.  */
    @Json(name = "add_index")
    val addIndex: kotlin.String,

    /* The state the invoice is in. */
    @Json(name = "state")
    val state: InvoiceState?,

    /* Optional memo to attach along with the invoice. Used for record keeping purposes for the invoice's creator,         and will also be set in the description field of the encoded payment request if the description_hash field is not being used. */
    @Json(name = "memo")
    val memo: kotlin.String? = null,

    /* The hex-encoded preimage(32 byte) which will allow settling an incoming HTLC payable to this preimage. */
    @Json(name = "r_preimage")
    val rPreimage: kotlin.String? = null,

    /* The hash of the preimage. */
    @Json(name = "r_hash")
    val rHash: kotlin.String? = null,

    /* Whether this invoice has been fulfilled */
    @Json(name = "settled")
    val settled: kotlin.Boolean? = false,

    /* When this invoice was created. Not available with CLN. */
    @Json(name = "creation_date")
    val creationDate: kotlin.Int? = null,

    /* When this invoice was settled. Not available with pending invoices. */
    @Json(name = "settle_date")
    val settleDate: kotlin.Int? = null,

    /* The time at which this invoice expires */
    @Json(name = "expiry_date")
    val expiryDate: kotlin.Int? = null,

    /* A bare-bones invoice for a payment within the     Lightning Network. With the details of the invoice, the sender has all the data necessary to     send a payment to the recipient.      */
    @Json(name = "payment_request")
    val paymentRequest: kotlin.String? = null,

    /*      Hash(SHA-256) of a description of the payment. Used if the description of payment(memo) is too     long to naturally fit within the description field of an encoded payment request.      */
    @Json(name = "description_hash")
    val descriptionHash: kotlin.String? = null,

    /* Payment request expiry time in seconds. Default is 3600 (1 hour). */
    @Json(name = "expiry")
    val expiry: kotlin.Int? = null,

    /* Fallback on-chain address. */
    @Json(name = "fallback_addr")
    val fallbackAddr: kotlin.String? = null,

    /* Delta to use for the time-lock of the CLTV extended to the final hop. */
    @Json(name = "cltv_expiry")
    val cltvExpiry: kotlin.Int? = null,

    /*      Route hints that can each be individually used to assist in reaching the invoice's destination.      */
    @Json(name = "route_hints")
    val routeHints: kotlin.collections.List<RouteHint>? = null,

    /* Whether this invoice should include routing hints for private channels. */
    @Json(name = "private")
    val `private`: kotlin.Boolean? = null,

    /*          The \"settle\" index of this invoice. Each newly settled invoice will  increment this index making it monotonically increasing.      */
    @Json(name = "settle_index")
    val settleIndex: kotlin.Int? = null,

    /*      The amount that was accepted for this invoice, in satoshis. This     will ONLY be set if this invoice has been settled. We provide     this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted.     Additionally, it's possible that the sender paid MORE that     was specified in the original invoice. So we'll record that here as well.      */
    @Json(name = "amt_paid_sat")
    val amtPaidSat: kotlin.Int? = null,

    /*      The amount that was accepted for this invoice, in millisatoshis.     This will ONLY be set if this invoice has been settled. We     provide this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted. Additionally,     it's possible that the sender paid MORE that was specified in the     original invoice. So we'll record that here as well.      */
    @Json(name = "amt_paid_msat")
    val amtPaidMsat: kotlin.Int? = null,

    /* List of HTLCs paying to this invoice[EXPERIMENTAL]. */
    @Json(name = "htlcs")
    val htlcs: kotlin.collections.List<InvoiceHTLC>? = null,

    /* List of features advertised on the invoice. */
    @Json(name = "features")
    val features: kotlin.collections.List<FeaturesEntry>? = null,

    /* [LND only] Indicates if this invoice was a spontaneous payment that arrived via keysend[EXPERIMENTAL]. */
    @Json(name = "is_keysend")
    val isKeysend: kotlin.Boolean? = null,

    /*  The payment address of this invoice. This value will be used in MPP payments,     and also for newer invoices that always require the MPP payload for added end-to-end security. */
    @Json(name = "payment_addr")
    val paymentAddr: kotlin.String? = null,

    /* Signals whether or not this is an AMP invoice. */
    @Json(name = "is_amp")
    val isAmp: kotlin.Boolean? = null

)

