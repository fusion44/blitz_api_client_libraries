/*
FastAPI

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// LightningApiService LightningApi service
type LightningApiService service

type ApiLightningAddInvoiceLightningAddInvoicePostRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	valueMsat *int32
	memo *string
	expiry *int32
	isKeysend *bool
}

func (r ApiLightningAddInvoiceLightningAddInvoicePostRequest) ValueMsat(valueMsat int32) ApiLightningAddInvoiceLightningAddInvoicePostRequest {
	r.valueMsat = &valueMsat
	return r
}

func (r ApiLightningAddInvoiceLightningAddInvoicePostRequest) Memo(memo string) ApiLightningAddInvoiceLightningAddInvoicePostRequest {
	r.memo = &memo
	return r
}

func (r ApiLightningAddInvoiceLightningAddInvoicePostRequest) Expiry(expiry int32) ApiLightningAddInvoiceLightningAddInvoicePostRequest {
	r.expiry = &expiry
	return r
}

func (r ApiLightningAddInvoiceLightningAddInvoicePostRequest) IsKeysend(isKeysend bool) ApiLightningAddInvoiceLightningAddInvoicePostRequest {
	r.isKeysend = &isKeysend
	return r
}

func (r ApiLightningAddInvoiceLightningAddInvoicePostRequest) Execute() (*Invoice, *http.Response, error) {
	return r.ApiService.LightningAddInvoiceLightningAddInvoicePostExecute(r)
}

/*
LightningAddInvoiceLightningAddInvoicePost Addinvoice adds a new Invoice to the database.

For additional information see [LND docs](https://api.lightning.community/#addinvoice)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningAddInvoiceLightningAddInvoicePostRequest
*/
func (a *LightningApiService) LightningAddInvoiceLightningAddInvoicePost(ctx context.Context) ApiLightningAddInvoiceLightningAddInvoicePostRequest {
	return ApiLightningAddInvoiceLightningAddInvoicePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Invoice
func (a *LightningApiService) LightningAddInvoiceLightningAddInvoicePostExecute(r ApiLightningAddInvoiceLightningAddInvoicePostRequest) (*Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningAddInvoiceLightningAddInvoicePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/add-invoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.valueMsat == nil {
		return localVarReturnValue, nil, reportError("valueMsat is required and must be specified")
	}

	localVarQueryParams.Add("value_msat", parameterToString(*r.valueMsat, ""))
	if r.memo != nil {
		localVarQueryParams.Add("memo", parameterToString(*r.memo, ""))
	}
	if r.expiry != nil {
		localVarQueryParams.Add("expiry", parameterToString(*r.expiry, ""))
	}
	if r.isKeysend != nil {
		localVarQueryParams.Add("is_keysend", parameterToString(*r.isKeysend, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningCloseChannelLightningCloseChannelPostRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	channelId *string
	forceClose *bool
}

func (r ApiLightningCloseChannelLightningCloseChannelPostRequest) ChannelId(channelId string) ApiLightningCloseChannelLightningCloseChannelPostRequest {
	r.channelId = &channelId
	return r
}

func (r ApiLightningCloseChannelLightningCloseChannelPostRequest) ForceClose(forceClose bool) ApiLightningCloseChannelLightningCloseChannelPostRequest {
	r.forceClose = &forceClose
	return r
}

func (r ApiLightningCloseChannelLightningCloseChannelPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LightningCloseChannelLightningCloseChannelPostExecute(r)
}

/*
LightningCloseChannelLightningCloseChannelPost close a channel

For additional information see [LND docs](https://api.lightning.community/#closechannel)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningCloseChannelLightningCloseChannelPostRequest
*/
func (a *LightningApiService) LightningCloseChannelLightningCloseChannelPost(ctx context.Context) ApiLightningCloseChannelLightningCloseChannelPostRequest {
	return ApiLightningCloseChannelLightningCloseChannelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *LightningApiService) LightningCloseChannelLightningCloseChannelPostExecute(r ApiLightningCloseChannelLightningCloseChannelPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningCloseChannelLightningCloseChannelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/close-channel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}
	if r.forceClose == nil {
		return localVarReturnValue, nil, reportError("forceClose is required and must be specified")
	}

	localVarQueryParams.Add("channel_id", parameterToString(*r.channelId, ""))
	localVarQueryParams.Add("force_close", parameterToString(*r.forceClose, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningDecodePayReqLightningDecodePayReqGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	payReq *string
}

// The payment request string to be decoded
func (r ApiLightningDecodePayReqLightningDecodePayReqGetRequest) PayReq(payReq string) ApiLightningDecodePayReqLightningDecodePayReqGetRequest {
	r.payReq = &payReq
	return r
}

func (r ApiLightningDecodePayReqLightningDecodePayReqGetRequest) Execute() (*PaymentRequest, *http.Response, error) {
	return r.ApiService.LightningDecodePayReqLightningDecodePayReqGetExecute(r)
}

/*
LightningDecodePayReqLightningDecodePayReqGet DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningDecodePayReqLightningDecodePayReqGetRequest
*/
func (a *LightningApiService) LightningDecodePayReqLightningDecodePayReqGet(ctx context.Context) ApiLightningDecodePayReqLightningDecodePayReqGetRequest {
	return ApiLightningDecodePayReqLightningDecodePayReqGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentRequest
func (a *LightningApiService) LightningDecodePayReqLightningDecodePayReqGetExecute(r ApiLightningDecodePayReqLightningDecodePayReqGetRequest) (*PaymentRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningDecodePayReqLightningDecodePayReqGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/decode-pay-req"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payReq == nil {
		return localVarReturnValue, nil, reportError("payReq is required and must be specified")
	}

	localVarQueryParams.Add("pay_req", parameterToString(*r.payReq, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningGetBalanceLightningGetBalanceGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
}

func (r ApiLightningGetBalanceLightningGetBalanceGetRequest) Execute() (*WalletBalance, *http.Response, error) {
	return r.ApiService.LightningGetBalanceLightningGetBalanceGetExecute(r)
}

/*
LightningGetBalanceLightningGetBalanceGet Get the current on chain and channel balances of the lighting wallet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningGetBalanceLightningGetBalanceGetRequest
*/
func (a *LightningApiService) LightningGetBalanceLightningGetBalanceGet(ctx context.Context) ApiLightningGetBalanceLightningGetBalanceGetRequest {
	return ApiLightningGetBalanceLightningGetBalanceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletBalance
func (a *LightningApiService) LightningGetBalanceLightningGetBalanceGetExecute(r ApiLightningGetBalanceLightningGetBalanceGetRequest) (*WalletBalance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletBalance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningGetBalanceLightningGetBalanceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/get-balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningGetFeeRevenueLightningGetFeeRevenueGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
}

func (r ApiLightningGetFeeRevenueLightningGetFeeRevenueGetRequest) Execute() (*FeeRevenue, *http.Response, error) {
	return r.ApiService.LightningGetFeeRevenueLightningGetFeeRevenueGetExecute(r)
}

/*
LightningGetFeeRevenueLightningGetFeeRevenueGet Returns the daily, weekly and monthly fee revenue earned.


Currently, year and total fees are always null. Backends don't return these values by default.
Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningGetFeeRevenueLightningGetFeeRevenueGetRequest
*/
func (a *LightningApiService) LightningGetFeeRevenueLightningGetFeeRevenueGet(ctx context.Context) ApiLightningGetFeeRevenueLightningGetFeeRevenueGetRequest {
	return ApiLightningGetFeeRevenueLightningGetFeeRevenueGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeeRevenue
func (a *LightningApiService) LightningGetFeeRevenueLightningGetFeeRevenueGetExecute(r ApiLightningGetFeeRevenueLightningGetFeeRevenueGetRequest) (*FeeRevenue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeeRevenue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningGetFeeRevenueLightningGetFeeRevenueGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/get-fee-revenue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningGetInfoLightningGetInfoGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
}

func (r ApiLightningGetInfoLightningGetInfoGetRequest) Execute() (*LnInfo, *http.Response, error) {
	return r.ApiService.LightningGetInfoLightningGetInfoGetExecute(r)
}

/*
LightningGetInfoLightningGetInfoGet Request information about the currently running lightning node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningGetInfoLightningGetInfoGetRequest
*/
func (a *LightningApiService) LightningGetInfoLightningGetInfoGet(ctx context.Context) ApiLightningGetInfoLightningGetInfoGetRequest {
	return ApiLightningGetInfoLightningGetInfoGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LnInfo
func (a *LightningApiService) LightningGetInfoLightningGetInfoGetExecute(r ApiLightningGetInfoLightningGetInfoGetRequest) (*LnInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LnInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningGetInfoLightningGetInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/get-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningGetInfoLiteLightningGetInfoLiteGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
}

func (r ApiLightningGetInfoLiteLightningGetInfoLiteGetRequest) Execute() (*LightningInfoLite, *http.Response, error) {
	return r.ApiService.LightningGetInfoLiteLightningGetInfoLiteGetExecute(r)
}

/*
LightningGetInfoLiteLightningGetInfoLiteGet Get lightweight current lightning info. Less verbose version of /lightning/get-info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningGetInfoLiteLightningGetInfoLiteGetRequest
*/
func (a *LightningApiService) LightningGetInfoLiteLightningGetInfoLiteGet(ctx context.Context) ApiLightningGetInfoLiteLightningGetInfoLiteGetRequest {
	return ApiLightningGetInfoLiteLightningGetInfoLiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LightningInfoLite
func (a *LightningApiService) LightningGetInfoLiteLightningGetInfoLiteGetExecute(r ApiLightningGetInfoLiteLightningGetInfoLiteGetRequest) (*LightningInfoLite, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LightningInfoLite
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningGetInfoLiteLightningGetInfoLiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/get-info-lite"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningListAllTxLightningListAllTxGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	successfulOnly *bool
	indexOffset *int32
	maxTx *int32
	reversed *bool
}

// If set, only successful transaction will be returned in the response.
func (r ApiLightningListAllTxLightningListAllTxGetRequest) SuccessfulOnly(successfulOnly bool) ApiLightningListAllTxLightningListAllTxGetRequest {
	r.successfulOnly = &successfulOnly
	return r
}

// The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response.
func (r ApiLightningListAllTxLightningListAllTxGetRequest) IndexOffset(indexOffset int32) ApiLightningListAllTxLightningListAllTxGetRequest {
	r.indexOffset = &indexOffset
	return r
}

// The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null.
func (r ApiLightningListAllTxLightningListAllTxGetRequest) MaxTx(maxTx int32) ApiLightningListAllTxLightningListAllTxGetRequest {
	r.maxTx = &maxTx
	return r
}

// If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
func (r ApiLightningListAllTxLightningListAllTxGetRequest) Reversed(reversed bool) ApiLightningListAllTxLightningListAllTxGetRequest {
	r.reversed = &reversed
	return r
}

func (r ApiLightningListAllTxLightningListAllTxGetRequest) Execute() ([]GenericTx, *http.Response, error) {
	return r.ApiService.LightningListAllTxLightningListAllTxGetExecute(r)
}

/*
LightningListAllTxLightningListAllTxGet Lists all on-chain transactions, payments and invoices in the wallet

Returns a list with all on-chain transaction, payments and invoices combined into one list.
    The index of each tx is only valid for each identical set of parameters.
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningListAllTxLightningListAllTxGetRequest
*/
func (a *LightningApiService) LightningListAllTxLightningListAllTxGet(ctx context.Context) ApiLightningListAllTxLightningListAllTxGetRequest {
	return ApiLightningListAllTxLightningListAllTxGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GenericTx
func (a *LightningApiService) LightningListAllTxLightningListAllTxGetExecute(r ApiLightningListAllTxLightningListAllTxGetRequest) ([]GenericTx, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GenericTx
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningListAllTxLightningListAllTxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/list-all-tx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.successfulOnly != nil {
		localVarQueryParams.Add("successful_only", parameterToString(*r.successfulOnly, ""))
	}
	if r.indexOffset != nil {
		localVarQueryParams.Add("index_offset", parameterToString(*r.indexOffset, ""))
	}
	if r.maxTx != nil {
		localVarQueryParams.Add("max_tx", parameterToString(*r.maxTx, ""))
	}
	if r.reversed != nil {
		localVarQueryParams.Add("reversed", parameterToString(*r.reversed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningListChannelsLightningListChannelsGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
}

func (r ApiLightningListChannelsLightningListChannelsGetRequest) Execute() ([]Channel, *http.Response, error) {
	return r.ApiService.LightningListChannelsLightningListChannelsGetExecute(r)
}

/*
LightningListChannelsLightningListChannelsGet Returns a list of open channels

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningListChannelsLightningListChannelsGetRequest
*/
func (a *LightningApiService) LightningListChannelsLightningListChannelsGet(ctx context.Context) ApiLightningListChannelsLightningListChannelsGetRequest {
	return ApiLightningListChannelsLightningListChannelsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Channel
func (a *LightningApiService) LightningListChannelsLightningListChannelsGetExecute(r ApiLightningListChannelsLightningListChannelsGetRequest) ([]Channel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Channel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningListChannelsLightningListChannelsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/list-channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningListInvoicesLightningListInvoicesGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	pendingOnly *bool
	indexOffset *int32
	numMaxInvoices *int32
	reversed *bool
}

// If set, only invoices that are not settled and not canceled will be returned in the response.
func (r ApiLightningListInvoicesLightningListInvoicesGetRequest) PendingOnly(pendingOnly bool) ApiLightningListInvoicesLightningListInvoicesGetRequest {
	r.pendingOnly = &pendingOnly
	return r
}

// The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response.
func (r ApiLightningListInvoicesLightningListInvoicesGetRequest) IndexOffset(indexOffset int32) ApiLightningListInvoicesLightningListInvoicesGetRequest {
	r.indexOffset = &indexOffset
	return r
}

// The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null.
func (r ApiLightningListInvoicesLightningListInvoicesGetRequest) NumMaxInvoices(numMaxInvoices int32) ApiLightningListInvoicesLightningListInvoicesGetRequest {
	r.numMaxInvoices = &numMaxInvoices
	return r
}

// If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
func (r ApiLightningListInvoicesLightningListInvoicesGetRequest) Reversed(reversed bool) ApiLightningListInvoicesLightningListInvoicesGetRequest {
	r.reversed = &reversed
	return r
}

func (r ApiLightningListInvoicesLightningListInvoicesGetRequest) Execute() ([]Invoice, *http.Response, error) {
	return r.ApiService.LightningListInvoicesLightningListInvoicesGetExecute(r)
}

/*
LightningListInvoicesLightningListInvoicesGet Lists all invoices from the wallet. Modeled after LND implementation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningListInvoicesLightningListInvoicesGetRequest
*/
func (a *LightningApiService) LightningListInvoicesLightningListInvoicesGet(ctx context.Context) ApiLightningListInvoicesLightningListInvoicesGetRequest {
	return ApiLightningListInvoicesLightningListInvoicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Invoice
func (a *LightningApiService) LightningListInvoicesLightningListInvoicesGetExecute(r ApiLightningListInvoicesLightningListInvoicesGetRequest) ([]Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningListInvoicesLightningListInvoicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/list-invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pendingOnly != nil {
		localVarQueryParams.Add("pending_only", parameterToString(*r.pendingOnly, ""))
	}
	if r.indexOffset != nil {
		localVarQueryParams.Add("index_offset", parameterToString(*r.indexOffset, ""))
	}
	if r.numMaxInvoices != nil {
		localVarQueryParams.Add("num_max_invoices", parameterToString(*r.numMaxInvoices, ""))
	}
	if r.reversed != nil {
		localVarQueryParams.Add("reversed", parameterToString(*r.reversed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningListOnchainTxLightningListOnchainTxGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
}

func (r ApiLightningListOnchainTxLightningListOnchainTxGetRequest) Execute() ([]OnChainTransaction, *http.Response, error) {
	return r.ApiService.LightningListOnchainTxLightningListOnchainTxGetExecute(r)
}

/*
LightningListOnchainTxLightningListOnchainTxGet Lists all onchain transactions from the wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningListOnchainTxLightningListOnchainTxGetRequest
*/
func (a *LightningApiService) LightningListOnchainTxLightningListOnchainTxGet(ctx context.Context) ApiLightningListOnchainTxLightningListOnchainTxGetRequest {
	return ApiLightningListOnchainTxLightningListOnchainTxGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OnChainTransaction
func (a *LightningApiService) LightningListOnchainTxLightningListOnchainTxGetExecute(r ApiLightningListOnchainTxLightningListOnchainTxGetRequest) ([]OnChainTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OnChainTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningListOnchainTxLightningListOnchainTxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/list-onchain-tx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningListPaymentsLightningListPaymentsGetRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	includeIncomplete *bool
	indexOffset *int32
	maxPayments *int32
	reversed *bool
}

// If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn&#39;t change the meaning of the indices, which are tied to individual payments.
func (r ApiLightningListPaymentsLightningListPaymentsGetRequest) IncludeIncomplete(includeIncomplete bool) ApiLightningListPaymentsLightningListPaymentsGetRequest {
	r.includeIncomplete = &includeIncomplete
	return r
}

// The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards.
func (r ApiLightningListPaymentsLightningListPaymentsGetRequest) IndexOffset(indexOffset int32) ApiLightningListPaymentsLightningListPaymentsGetRequest {
	r.indexOffset = &indexOffset
	return r
}

// The maximal number of payments returned in the response to this query.
func (r ApiLightningListPaymentsLightningListPaymentsGetRequest) MaxPayments(maxPayments int32) ApiLightningListPaymentsLightningListPaymentsGetRequest {
	r.maxPayments = &maxPayments
	return r
}

// If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order).
func (r ApiLightningListPaymentsLightningListPaymentsGetRequest) Reversed(reversed bool) ApiLightningListPaymentsLightningListPaymentsGetRequest {
	r.reversed = &reversed
	return r
}

func (r ApiLightningListPaymentsLightningListPaymentsGetRequest) Execute() ([]Payment, *http.Response, error) {
	return r.ApiService.LightningListPaymentsLightningListPaymentsGetExecute(r)
}

/*
LightningListPaymentsLightningListPaymentsGet Returns a list of all outgoing payments. Modeled after LND implementation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningListPaymentsLightningListPaymentsGetRequest
*/
func (a *LightningApiService) LightningListPaymentsLightningListPaymentsGet(ctx context.Context) ApiLightningListPaymentsLightningListPaymentsGetRequest {
	return ApiLightningListPaymentsLightningListPaymentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Payment
func (a *LightningApiService) LightningListPaymentsLightningListPaymentsGetExecute(r ApiLightningListPaymentsLightningListPaymentsGetRequest) ([]Payment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningListPaymentsLightningListPaymentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/list-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeIncomplete != nil {
		localVarQueryParams.Add("include_incomplete", parameterToString(*r.includeIncomplete, ""))
	}
	if r.indexOffset != nil {
		localVarQueryParams.Add("index_offset", parameterToString(*r.indexOffset, ""))
	}
	if r.maxPayments != nil {
		localVarQueryParams.Add("max_payments", parameterToString(*r.maxPayments, ""))
	}
	if r.reversed != nil {
		localVarQueryParams.Add("reversed", parameterToString(*r.reversed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningNewAddressLightningNewAddressPostRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	newAddressInput *NewAddressInput
}

func (r ApiLightningNewAddressLightningNewAddressPostRequest) NewAddressInput(newAddressInput NewAddressInput) ApiLightningNewAddressLightningNewAddressPostRequest {
	r.newAddressInput = &newAddressInput
	return r
}

func (r ApiLightningNewAddressLightningNewAddressPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LightningNewAddressLightningNewAddressPostExecute(r)
}

/*
LightningNewAddressLightningNewAddressPost Generate a new on-chain address


Generate a wallet new address. Address-types has to be one of:
* **p2wkh**:  Pay to witness key hash (bech32)
* **np2wkh**: Pay to nested witness key hash
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningNewAddressLightningNewAddressPostRequest
*/
func (a *LightningApiService) LightningNewAddressLightningNewAddressPost(ctx context.Context) ApiLightningNewAddressLightningNewAddressPostRequest {
	return ApiLightningNewAddressLightningNewAddressPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *LightningApiService) LightningNewAddressLightningNewAddressPostExecute(r ApiLightningNewAddressLightningNewAddressPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningNewAddressLightningNewAddressPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/new-address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newAddressInput == nil {
		return localVarReturnValue, nil, reportError("newAddressInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newAddressInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningOpenChannelLightningOpenChannelPostRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	localFundingAmount *int32
	nodeURI *string
	targetConfs *int32
}

func (r ApiLightningOpenChannelLightningOpenChannelPostRequest) LocalFundingAmount(localFundingAmount int32) ApiLightningOpenChannelLightningOpenChannelPostRequest {
	r.localFundingAmount = &localFundingAmount
	return r
}

func (r ApiLightningOpenChannelLightningOpenChannelPostRequest) NodeURI(nodeURI string) ApiLightningOpenChannelLightningOpenChannelPostRequest {
	r.nodeURI = &nodeURI
	return r
}

func (r ApiLightningOpenChannelLightningOpenChannelPostRequest) TargetConfs(targetConfs int32) ApiLightningOpenChannelLightningOpenChannelPostRequest {
	r.targetConfs = &targetConfs
	return r
}

func (r ApiLightningOpenChannelLightningOpenChannelPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LightningOpenChannelLightningOpenChannelPostExecute(r)
}

/*
LightningOpenChannelLightningOpenChannelPost open a new lightning channel


__open-channel__ attempts to open a channel with a peer.

### LND:
_target_conf_: The target number of blocks that the funding transaction should be confirmed by.

### c-lightning:
* Set _target_conf_ ==1: interpreted as urgent (aim for next block)
* Set _target_conf_ >=2: interpreted as normal (next 4 blocks or so, **default**)
* Set _target_cont_ >=10: interpreted as slow (next 100 blocks or so)

>  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningOpenChannelLightningOpenChannelPostRequest
*/
func (a *LightningApiService) LightningOpenChannelLightningOpenChannelPost(ctx context.Context) ApiLightningOpenChannelLightningOpenChannelPostRequest {
	return ApiLightningOpenChannelLightningOpenChannelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *LightningApiService) LightningOpenChannelLightningOpenChannelPostExecute(r ApiLightningOpenChannelLightningOpenChannelPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningOpenChannelLightningOpenChannelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/open-channel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.localFundingAmount == nil {
		return localVarReturnValue, nil, reportError("localFundingAmount is required and must be specified")
	}
	if r.nodeURI == nil {
		return localVarReturnValue, nil, reportError("nodeURI is required and must be specified")
	}

	localVarQueryParams.Add("local_funding_amount", parameterToString(*r.localFundingAmount, ""))
	localVarQueryParams.Add("node_URI", parameterToString(*r.nodeURI, ""))
	if r.targetConfs != nil {
		localVarQueryParams.Add("target_confs", parameterToString(*r.targetConfs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningSendCoinsLightningSendCoinsPostRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	sendCoinsInput *SendCoinsInput
}

func (r ApiLightningSendCoinsLightningSendCoinsPostRequest) SendCoinsInput(sendCoinsInput SendCoinsInput) ApiLightningSendCoinsLightningSendCoinsPostRequest {
	r.sendCoinsInput = &sendCoinsInput
	return r
}

func (r ApiLightningSendCoinsLightningSendCoinsPostRequest) Execute() (*SendCoinsResponse, *http.Response, error) {
	return r.ApiService.LightningSendCoinsLightningSendCoinsPostExecute(r)
}

/*
LightningSendCoinsLightningSendCoinsPost Attempt to send on-chain funds.


__send-coins__ executes a request to send coins to a particular address.

### LND:
If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.

>  See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)

### c-lightning:
* Set __target_conf__ ==1: interpreted as urgent (aim for next block)
* Set __target_conf__ >=2: interpreted as normal (next 4 blocks or so, **default**)
* Set __target_cont__ >=10: interpreted as slow (next 100 blocks or so)
* If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.

>  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningSendCoinsLightningSendCoinsPostRequest
*/
func (a *LightningApiService) LightningSendCoinsLightningSendCoinsPost(ctx context.Context) ApiLightningSendCoinsLightningSendCoinsPostRequest {
	return ApiLightningSendCoinsLightningSendCoinsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendCoinsResponse
func (a *LightningApiService) LightningSendCoinsLightningSendCoinsPostExecute(r ApiLightningSendCoinsLightningSendCoinsPostRequest) (*SendCoinsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendCoinsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningSendCoinsLightningSendCoinsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/send-coins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sendCoinsInput == nil {
		return localVarReturnValue, nil, reportError("sendCoinsInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendCoinsInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningSendPaymentLightningSendPaymentPostRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	payReq *string
	timeoutSeconds *int32
	feeLimitMsat *int32
	amountMsat *int32
}

func (r ApiLightningSendPaymentLightningSendPaymentPostRequest) PayReq(payReq string) ApiLightningSendPaymentLightningSendPaymentPostRequest {
	r.payReq = &payReq
	return r
}

func (r ApiLightningSendPaymentLightningSendPaymentPostRequest) TimeoutSeconds(timeoutSeconds int32) ApiLightningSendPaymentLightningSendPaymentPostRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiLightningSendPaymentLightningSendPaymentPostRequest) FeeLimitMsat(feeLimitMsat int32) ApiLightningSendPaymentLightningSendPaymentPostRequest {
	r.feeLimitMsat = &feeLimitMsat
	return r
}

func (r ApiLightningSendPaymentLightningSendPaymentPostRequest) AmountMsat(amountMsat int32) ApiLightningSendPaymentLightningSendPaymentPostRequest {
	r.amountMsat = &amountMsat
	return r
}

func (r ApiLightningSendPaymentLightningSendPaymentPostRequest) Execute() (*Payment, *http.Response, error) {
	return r.ApiService.LightningSendPaymentLightningSendPaymentPostExecute(r)
}

/*
LightningSendPaymentLightningSendPaymentPost Attempt to pay a payment request.


This endpoints attempts to pay a payment request.

Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningSendPaymentLightningSendPaymentPostRequest
*/
func (a *LightningApiService) LightningSendPaymentLightningSendPaymentPost(ctx context.Context) ApiLightningSendPaymentLightningSendPaymentPostRequest {
	return ApiLightningSendPaymentLightningSendPaymentPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Payment
func (a *LightningApiService) LightningSendPaymentLightningSendPaymentPostExecute(r ApiLightningSendPaymentLightningSendPaymentPostRequest) (*Payment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningSendPaymentLightningSendPaymentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/send-payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payReq == nil {
		return localVarReturnValue, nil, reportError("payReq is required and must be specified")
	}

	localVarQueryParams.Add("pay_req", parameterToString(*r.payReq, ""))
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeout_seconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.feeLimitMsat != nil {
		localVarQueryParams.Add("fee_limit_msat", parameterToString(*r.feeLimitMsat, ""))
	}
	if r.amountMsat != nil {
		localVarQueryParams.Add("amount_msat", parameterToString(*r.amountMsat, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLightningUnlockWalletLightningUnlockWalletPostRequest struct {
	ctx context.Context
	ApiService *LightningApiService
	unlockWalletInput *UnlockWalletInput
}

func (r ApiLightningUnlockWalletLightningUnlockWalletPostRequest) UnlockWalletInput(unlockWalletInput UnlockWalletInput) ApiLightningUnlockWalletLightningUnlockWalletPostRequest {
	r.unlockWalletInput = &unlockWalletInput
	return r
}

func (r ApiLightningUnlockWalletLightningUnlockWalletPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.LightningUnlockWalletLightningUnlockWalletPostExecute(r)
}

/*
LightningUnlockWalletLightningUnlockWalletPost Unlocks a locked wallet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLightningUnlockWalletLightningUnlockWalletPostRequest
*/
func (a *LightningApiService) LightningUnlockWalletLightningUnlockWalletPost(ctx context.Context) ApiLightningUnlockWalletLightningUnlockWalletPostRequest {
	return ApiLightningUnlockWalletLightningUnlockWalletPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *LightningApiService) LightningUnlockWalletLightningUnlockWalletPostExecute(r ApiLightningUnlockWalletLightningUnlockWalletPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LightningApiService.LightningUnlockWalletLightningUnlockWalletPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lightning/unlock-wallet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unlockWalletInput == nil {
		return localVarReturnValue, nil, reportError("unlockWalletInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unlockWalletInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
