/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AMP
 */
export interface AMP {
    /**
     * 
     * @type {string}
     * @memberof AMP
     */
    'root_share': string;
    /**
     * 
     * @type {string}
     * @memberof AMP
     */
    'set_id': string;
    /**
     * 
     * @type {number}
     * @memberof AMP
     */
    'child_index': number;
    /**
     * 
     * @type {string}
     * @memberof AMP
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof AMP
     */
    'preimage': string;
}
/**
 * 
 * @export
 * @interface AMPRecord
 */
export interface AMPRecord {
    /**
     * 
     * @type {string}
     * @memberof AMPRecord
     */
    'root_share': string;
    /**
     * 
     * @type {string}
     * @memberof AMPRecord
     */
    'set_id': string;
    /**
     * 
     * @type {number}
     * @memberof AMPRecord
     */
    'child_index': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const APIPlatform = {
    Raspiblitz: 'raspiblitz',
    NativePython: 'native_python',
    Unknown: 'unknown'
} as const;

export type APIPlatform = typeof APIPlatform[keyof typeof APIPlatform];


/**
 * Details relevant to AMP HTLCs, only populated if this is an AMP HTLC.
 * @export
 * @interface Amp
 */
export interface Amp {
    /**
     * 
     * @type {string}
     * @memberof Amp
     */
    'root_share': string;
    /**
     * 
     * @type {string}
     * @memberof Amp
     */
    'set_id': string;
    /**
     * 
     * @type {number}
     * @memberof Amp
     */
    'child_index': number;
    /**
     * 
     * @type {string}
     * @memberof Amp
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof Amp
     */
    'preimage': string;
}
/**
 * Status of bip9 softforks(only for \"bip9\" type)
 * @export
 * @interface Bip9
 */
export interface Bip9 {
    /**
     * One of \"defined\", \"started\", \"locked_in\", \"active\", \"failed\" 
     * @type {string}
     * @memberof Bip9
     */
    'status': string;
    /**
     * the bit(0-28) in the block version field used to signal this softfork(only for `started` status)
     * @type {number}
     * @memberof Bip9
     */
    'bit'?: number;
    /**
     * The minimum median time past of a block at which the bit gains its meaning
     * @type {number}
     * @memberof Bip9
     */
    'start_time': number;
    /**
     * The median time past of a block at which the deployment is considered failed if not yet locked in
     * @type {number}
     * @memberof Bip9
     */
    'timeout': number;
    /**
     * Height of the first block to which the status applies
     * @type {number}
     * @memberof Bip9
     */
    'since': number;
    /**
     * Minimum height of blocks for which the rules may be enforced
     * @type {number}
     * @memberof Bip9
     */
    'min_activation_height': number;
    /**
     * 
     * @type {Statistics}
     * @memberof Bip9
     */
    'statistics'?: Statistics;
    /**
     * Height of the first block which the rules are or will be enforced(only for `buried` type, or `bip9` type with `active` status)
     * @type {number}
     * @memberof Bip9
     */
    'height'?: number;
    /**
     * True if the rules are enforced for the mempool and the next block
     * @type {boolean}
     * @memberof Bip9
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface Bip9Data
 */
export interface Bip9Data {
    /**
     * One of \"defined\", \"started\", \"locked_in\", \"active\", \"failed\" 
     * @type {string}
     * @memberof Bip9Data
     */
    'status': string;
    /**
     * the bit(0-28) in the block version field used to signal this softfork(only for `started` status)
     * @type {number}
     * @memberof Bip9Data
     */
    'bit'?: number;
    /**
     * The minimum median time past of a block at which the bit gains its meaning
     * @type {number}
     * @memberof Bip9Data
     */
    'start_time': number;
    /**
     * The median time past of a block at which the deployment is considered failed if not yet locked in
     * @type {number}
     * @memberof Bip9Data
     */
    'timeout': number;
    /**
     * Height of the first block to which the status applies
     * @type {number}
     * @memberof Bip9Data
     */
    'since': number;
    /**
     * Minimum height of blocks for which the rules may be enforced
     * @type {number}
     * @memberof Bip9Data
     */
    'min_activation_height': number;
    /**
     * 
     * @type {Statistics}
     * @memberof Bip9Data
     */
    'statistics'?: Statistics;
    /**
     * Height of the first block which the rules are or will be enforced(only for `buried` type, or `bip9` type with `active` status)
     * @type {number}
     * @memberof Bip9Data
     */
    'height'?: number;
    /**
     * True if the rules are enforced for the mempool and the next block
     * @type {boolean}
     * @memberof Bip9Data
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface Bip9Statistics
 */
export interface Bip9Statistics {
    /**
     * The length in blocks of the BIP9 signalling period
     * @type {number}
     * @memberof Bip9Statistics
     */
    'period': number;
    /**
     * The number of blocks with the version bit set required to activate the feature
     * @type {number}
     * @memberof Bip9Statistics
     */
    'threshold': number;
    /**
     * The number of blocks elapsed since the beginning of the current period
     * @type {number}
     * @memberof Bip9Statistics
     */
    'elapsed': number;
    /**
     * The number of blocks with the version bit set in the current period
     * @type {number}
     * @memberof Bip9Statistics
     */
    'count': number;
    /**
     * False if there are not enough blocks left in this period to pass activation threshold
     * @type {boolean}
     * @memberof Bip9Statistics
     */
    'possible': boolean;
}
/**
 * 
 * @export
 * @interface BlockchainInfo
 */
export interface BlockchainInfo {
    /**
     * Current network name(main, test, regtest)
     * @type {string}
     * @memberof BlockchainInfo
     */
    'chain': string;
    /**
     * The height of the most-work fully-validated chain. The genesis block has height 0
     * @type {number}
     * @memberof BlockchainInfo
     */
    'blocks': number;
    /**
     * The current number of headers we have validated
     * @type {number}
     * @memberof BlockchainInfo
     */
    'headers': number;
    /**
     * The hash of the currently best block
     * @type {string}
     * @memberof BlockchainInfo
     */
    'best_block_hash': string;
    /**
     * The current difficulty
     * @type {number}
     * @memberof BlockchainInfo
     */
    'difficulty': number;
    /**
     * Median time for the current best block
     * @type {number}
     * @memberof BlockchainInfo
     */
    'mediantime': number;
    /**
     * Estimate of verification progress[0..1]
     * @type {number}
     * @memberof BlockchainInfo
     */
    'verification_progress': number;
    /**
     * Estimate of whether this node is in Initial Block Download mode
     * @type {boolean}
     * @memberof BlockchainInfo
     */
    'initial_block_download': boolean;
    /**
     * total amount of work in active chain, in hexadecimal
     * @type {string}
     * @memberof BlockchainInfo
     */
    'chainwork': string;
    /**
     * The estimated size of the block and undo files on disk
     * @type {number}
     * @memberof BlockchainInfo
     */
    'size_on_disk': number;
    /**
     * If the blocks are subject to pruning
     * @type {boolean}
     * @memberof BlockchainInfo
     */
    'pruned': boolean;
    /**
     * Lowest-height complete block stored(only present if pruning is enabled)
     * @type {number}
     * @memberof BlockchainInfo
     */
    'prune_height'?: number;
    /**
     * Whether automatic pruning is enabled(only present if pruning is enabled)
     * @type {boolean}
     * @memberof BlockchainInfo
     */
    'automatic_pruning'?: boolean;
    /**
     * The target size used by pruning(only present if automatic pruning is enabled)
     * @type {number}
     * @memberof BlockchainInfo
     */
    'prune_target_size'?: number;
    /**
     * Any network and blockchain warnings
     * @type {string}
     * @memberof BlockchainInfo
     */
    'warnings': string;
    /**
     * Status of softforks
     * @type {Array<SoftFork>}
     * @memberof BlockchainInfo
     */
    'softforks': Array<SoftFork>;
}
/**
 * 
 * @export
 * @interface BtcInfo
 */
export interface BtcInfo {
    /**
     * The height of the most-work fully-validated chain. The genesis block has height 0
     * @type {number}
     * @memberof BtcInfo
     */
    'blocks': number;
    /**
     * The current number of headers we have validated
     * @type {number}
     * @memberof BtcInfo
     */
    'headers': number;
    /**
     * Estimate of verification progress[0..1]
     * @type {number}
     * @memberof BtcInfo
     */
    'verification_progress': number;
    /**
     * The current difficulty
     * @type {number}
     * @memberof BtcInfo
     */
    'difficulty': number;
    /**
     * The estimated size of the block and undo files on disk
     * @type {number}
     * @memberof BtcInfo
     */
    'size_on_disk': number;
    /**
     * Which networks are in use (ipv4, ipv6 or onion)
     * @type {Array<BtcNetwork>}
     * @memberof BtcInfo
     */
    'networks'?: Array<BtcNetwork>;
    /**
     * The bitcoin core server version
     * @type {number}
     * @memberof BtcInfo
     */
    'version': number;
    /**
     * The server subversion string
     * @type {string}
     * @memberof BtcInfo
     */
    'subversion': string;
    /**
     * The number of inbound connections
     * @type {number}
     * @memberof BtcInfo
     */
    'connections_in': number;
    /**
     * The number of outbound connections
     * @type {number}
     * @memberof BtcInfo
     */
    'connections_out': number;
}
/**
 * 
 * @export
 * @interface BtcLocalAddress
 */
export interface BtcLocalAddress {
    /**
     * Network address
     * @type {string}
     * @memberof BtcLocalAddress
     */
    'address': string;
    /**
     * Network port
     * @type {number}
     * @memberof BtcLocalAddress
     */
    'port': number;
    /**
     * Relative score
     * @type {number}
     * @memberof BtcLocalAddress
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface BtcNetwork
 */
export interface BtcNetwork {
    /**
     * Which network is in use (ipv4, ipv6 or onion)
     * @type {string}
     * @memberof BtcNetwork
     */
    'name': string;
    /**
     * Is the network limited using - onlynet?
     * @type {boolean}
     * @memberof BtcNetwork
     */
    'limited': boolean;
    /**
     * Is the network reachable?
     * @type {boolean}
     * @memberof BtcNetwork
     */
    'reachable': boolean;
    /**
     * host:port of the proxy that is used for this network, or empty if none
     * @type {string}
     * @memberof BtcNetwork
     */
    'proxy'?: string;
    /**
     * Whether randomized credentials are used
     * @type {boolean}
     * @memberof BtcNetwork
     */
    'proxy_randomize_credentials': boolean;
}
/**
 * 
 * @export
 * @interface Chain
 */
export interface Chain {
    /**
     * 
     * @type {string}
     * @memberof Chain
     */
    'chain': string;
    /**
     * 
     * @type {string}
     * @memberof Chain
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'channel_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Channel
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'peer_publickey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'peer_alias'?: string;
    /**
     * 
     * @type {number}
     * @memberof Channel
     */
    'balance_local'?: number;
    /**
     * 
     * @type {number}
     * @memberof Channel
     */
    'balance_remote'?: number;
    /**
     * 
     * @type {number}
     * @memberof Channel
     */
    'balance_capacity'?: number;
}
/**
 * 
 * @export
 * @interface ChannelUpdate
 */
export interface ChannelUpdate {
    /**
     * 
     * @type {string}
     * @memberof ChannelUpdate
     */
    'signature': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelUpdate
     */
    'chain_hash': string;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'chan_id': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'message_flags': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'channel_flags': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'time_lock_delta': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'htlc_minimum_msat': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'base_fee': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'fee_rate': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelUpdate
     */
    'htlc_maximum_msat': number;
    /**
     * 
     * @type {string}
     * @memberof ChannelUpdate
     */
    'extra_opaque_data': string;
}
/**
 * 
 * @export
 * @interface ConnectionInfo
 */
export interface ConnectionInfo {
    /**
     * lnd macaroon with admin rights in hexstring format
     * @type {string}
     * @memberof ConnectionInfo
     */
    'lnd_admin_macaroon'?: string;
    /**
     * lnd macaroon that only creates invoices in hexstring format
     * @type {string}
     * @memberof ConnectionInfo
     */
    'lnd_invoice_macaroon'?: string;
    /**
     * lnd macaroon with only read-only rights in hexstring format
     * @type {string}
     * @memberof ConnectionInfo
     */
    'lnd_readonly_macaroon'?: string;
    /**
     * lnd tls cert in hexstring format
     * @type {string}
     * @memberof ConnectionInfo
     */
    'lnd_tls_cert'?: string;
    /**
     * lnd rest api onion address
     * @type {string}
     * @memberof ConnectionInfo
     */
    'lnd_rest_onion'?: string;
    /**
     * connect BtcPay server locally to your lnd lightning node
     * @type {string}
     * @memberof ConnectionInfo
     */
    'lnd_btcpay_connection_string'?: string;
    /**
     * connect Zeus app to your lnd lightning node
     * @type {string}
     * @memberof ConnectionInfo
     */
    'lnd_zeus_connection_string'?: string;
    /**
     * connect Zeus app to your core lightning node over rest
     * @type {string}
     * @memberof ConnectionInfo
     */
    'cl_rest_zeus_connection_string'?: string;
    /**
     * core lightning rest macaroon
     * @type {string}
     * @memberof ConnectionInfo
     */
    'cl_rest_macaroon'?: string;
    /**
     * core lightning rest onion address
     * @type {string}
     * @memberof ConnectionInfo
     */
    'cl_rest_onion'?: string;
}
/**
 * 
 * @export
 * @interface CustomRecordsEntry
 */
export interface CustomRecordsEntry {
    /**
     * 
     * @type {number}
     * @memberof CustomRecordsEntry
     */
    'key': number;
    /**
     * 
     * @type {string}
     * @memberof CustomRecordsEntry
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Feature
     */
    'is_required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Feature
     */
    'is_known'?: boolean;
}
/**
 * 
 * @export
 * @interface FeaturesEntry
 */
export interface FeaturesEntry {
    /**
     * 
     * @type {number}
     * @memberof FeaturesEntry
     */
    'key': number;
    /**
     * 
     * @type {Feature}
     * @memberof FeaturesEntry
     */
    'value': Feature;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const FeeEstimationMode = {
    Conservative: 'conservative',
    Economical: 'economical'
} as const;

export type FeeEstimationMode = typeof FeeEstimationMode[keyof typeof FeeEstimationMode];


/**
 * 
 * @export
 * @interface FeeRevenue
 */
export interface FeeRevenue {
    /**
     * Fee revenue earned in the last 24 hours
     * @type {number}
     * @memberof FeeRevenue
     */
    'day': number;
    /**
     * Fee revenue earned in the last 7days
     * @type {number}
     * @memberof FeeRevenue
     */
    'week': number;
    /**
     * Fee revenue earned in the last month
     * @type {number}
     * @memberof FeeRevenue
     */
    'month': number;
    /**
     * Fee revenue earned in the last year. Might be null if not implemented by backend.
     * @type {number}
     * @memberof FeeRevenue
     */
    'year'?: number;
    /**
     * Fee revenue earned in the last year. Might be null if not implemented by backend
     * @type {number}
     * @memberof FeeRevenue
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface GenericTx
 */
export interface GenericTx {
    /**
     * The index of the transaction.
     * @type {number}
     * @memberof GenericTx
     */
    'index'?: number;
    /**
     *  Unique identifier for this transaction.  Depending on the type of the transaction it will be different: #### On-chain The transaction hash  #### Lightning Invoice and Payment The payment request 
     * @type {string}
     * @memberof GenericTx
     */
    'id': string;
    /**
     * Whether this is an onchain (**onchain**) or lightning (**ln**) transaction.
     * @type {TxCategory}
     * @memberof GenericTx
     */
    'category': TxCategory;
    /**
     * Whether this is an outgoing (**send**) transaction or an incoming (**receive**) transaction.
     * @type {TxType}
     * @memberof GenericTx
     */
    'type': TxType;
    /**
     *  The value of the transaction, depending on the category in satoshis or millisatoshis.  #### On-chain Transaction amount in satoshis  #### Lightning Invoice * value in millisatoshis of the invoice if *unsettled* * amount in millisatoshis paid if invoice is *settled*  #### Lightning Payment * amount sent in millisatoshis  
     * @type {number}
     * @memberof GenericTx
     */
    'amount': number;
    /**
     *  The unix timestamp in seconds for the transaction.  The timestamp can mean different things in different situations:  #### Lightning Invoice * Creation date for in-flight or failed invoices * Settle date for succeeded invoices  #### On-chain * Creation date for transaction waiting in the mempool * Timestamp of the block where this transaction is included  #### Lightning Payment  
     * @type {number}
     * @memberof GenericTx
     */
    'time_stamp': number;
    /**
     * Optional comment for this transaction
     * @type {string}
     * @memberof GenericTx
     */
    'comment'?: string;
    /**
     *  The status of the transaction. Depending on the transaction category this can be different values:  May have different meanings in different situations: #### unknown An unknown state was found.  #### in_flight * A lightning payment is being sent * An invoice is waiting for the incoming payment * An on-chain transaction is waiting in the mempool  #### succeeded * A lighting payment was successfully sent * An incoming payment was received for an invoice * An on-chain transaction was included in a block  #### failed * A lightning payment attempt which could not be completed (no route found, insufficient funds, ...) * An invoice is expired or some other error happened 
     * @type {TxStatus}
     * @memberof GenericTx
     */
    'status': TxStatus;
    /**
     * Block height, if included in a block. Only applicable for category **onchain**.
     * @type {number}
     * @memberof GenericTx
     */
    'block_height'?: number;
    /**
     * Number of confirmations. Only applicable for category **onchain**.
     * @type {number}
     * @memberof GenericTx
     */
    'num_confs'?: number;
    /**
     * Total fees paid for this transaction
     * @type {number}
     * @memberof GenericTx
     */
    'total_fees'?: number;
}
/**
 * 
 * @export
 * @interface HTLCAttempt
 */
export interface HTLCAttempt {
    /**
     * 
     * @type {number}
     * @memberof HTLCAttempt
     */
    'attempt_id': number;
    /**
     * 
     * @type {HTLCStatus}
     * @memberof HTLCAttempt
     */
    'status': HTLCStatus;
    /**
     * 
     * @type {Route}
     * @memberof HTLCAttempt
     */
    'route': Route;
    /**
     * 
     * @type {number}
     * @memberof HTLCAttempt
     */
    'attempt_time_ns': number;
    /**
     * 
     * @type {number}
     * @memberof HTLCAttempt
     */
    'resolve_time_ns': number;
    /**
     * 
     * @type {HTLCAttemptFailure}
     * @memberof HTLCAttempt
     */
    'failure': HTLCAttemptFailure;
    /**
     * 
     * @type {string}
     * @memberof HTLCAttempt
     */
    'preimage': string;
}
/**
 * 
 * @export
 * @interface HTLCAttemptFailure
 */
export interface HTLCAttemptFailure {
    /**
     * 
     * @type {number}
     * @memberof HTLCAttemptFailure
     */
    'code': number;
    /**
     * 
     * @type {ChannelUpdate}
     * @memberof HTLCAttemptFailure
     */
    'channel_update': ChannelUpdate;
    /**
     * 
     * @type {number}
     * @memberof HTLCAttemptFailure
     */
    'htlc_msat': number;
    /**
     * 
     * @type {string}
     * @memberof HTLCAttemptFailure
     */
    'onion_sha_256': string;
    /**
     * 
     * @type {number}
     * @memberof HTLCAttemptFailure
     */
    'cltv_expiry': number;
    /**
     * 
     * @type {number}
     * @memberof HTLCAttemptFailure
     */
    'flags': number;
    /**
     * 
     * @type {number}
     * @memberof HTLCAttemptFailure
     */
    'failure_source_index': number;
    /**
     * 
     * @type {number}
     * @memberof HTLCAttemptFailure
     */
    'height': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const HTLCStatus = {
    InFlight: 'in_flight',
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type HTLCStatus = typeof HTLCStatus[keyof typeof HTLCStatus];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Hop
 */
export interface Hop {
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'chan_id': number;
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'chan_capacity': number;
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'amt_to_forward': number;
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'fee': number;
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'expiry': number;
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'amt_to_forward_msat': number;
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'fee_msat': number;
    /**
     * 
     * @type {string}
     * @memberof Hop
     */
    'pub_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof Hop
     */
    'tlv_payload': boolean;
}
/**
 * 
 * @export
 * @interface HopHint
 */
export interface HopHint {
    /**
     * The public key of the node at the start of the channel.
     * @type {string}
     * @memberof HopHint
     */
    'node_id': string;
    /**
     * The unique identifier of the channel.
     * @type {string}
     * @memberof HopHint
     */
    'chan_id': string;
    /**
     * The base fee of the channel denominated in msat.
     * @type {number}
     * @memberof HopHint
     */
    'fee_base_msat': number;
    /**
     * The fee rate of the channel for sending one satoshi across it denominated in msat
     * @type {number}
     * @memberof HopHint
     */
    'fee_proportional_millionths': number;
    /**
     * The time-lock delta of the channel.
     * @type {number}
     * @memberof HopHint
     */
    'cltv_expiry_delta': number;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * Optional memo to attach along with the invoice. Used for record keeping purposes for the invoice\'s creator,         and will also be set in the description field of the encoded payment request if the description_hash field is not being used.
     * @type {string}
     * @memberof Invoice
     */
    'memo'?: string;
    /**
     * The hex-encoded preimage(32 byte) which will allow settling an incoming HTLC payable to this preimage.
     * @type {string}
     * @memberof Invoice
     */
    'r_preimage'?: string;
    /**
     * The hash of the preimage.
     * @type {string}
     * @memberof Invoice
     */
    'r_hash'?: string;
    /**
     * The value of this invoice in milli satoshis.
     * @type {number}
     * @memberof Invoice
     */
    'value_msat': number;
    /**
     * Whether this invoice has been fulfilled
     * @type {boolean}
     * @memberof Invoice
     */
    'settled'?: boolean;
    /**
     * When this invoice was created. Not available with CLN.
     * @type {number}
     * @memberof Invoice
     */
    'creation_date'?: number;
    /**
     * When this invoice was settled. Not available with pending invoices.
     * @type {number}
     * @memberof Invoice
     */
    'settle_date'?: number;
    /**
     * The time at which this invoice expires
     * @type {number}
     * @memberof Invoice
     */
    'expiry_date'?: number;
    /**
     * A bare-bones invoice for a payment within the     Lightning Network. With the details of the invoice, the sender has all the data necessary to     send a payment to the recipient.     
     * @type {string}
     * @memberof Invoice
     */
    'payment_request'?: string;
    /**
     *      Hash(SHA-256) of a description of the payment. Used if the description of payment(memo) is too     long to naturally fit within the description field of an encoded payment request.     
     * @type {string}
     * @memberof Invoice
     */
    'description_hash'?: string;
    /**
     * Payment request expiry time in seconds. Default is 3600 (1 hour).
     * @type {number}
     * @memberof Invoice
     */
    'expiry'?: number;
    /**
     * Fallback on-chain address.
     * @type {string}
     * @memberof Invoice
     */
    'fallback_addr'?: string;
    /**
     * Delta to use for the time-lock of the CLTV extended to the final hop.
     * @type {number}
     * @memberof Invoice
     */
    'cltv_expiry'?: number;
    /**
     *      Route hints that can each be individually used to assist in reaching the invoice\'s destination.     
     * @type {Array<RouteHint>}
     * @memberof Invoice
     */
    'route_hints'?: Array<RouteHint>;
    /**
     * Whether this invoice should include routing hints for private channels.
     * @type {boolean}
     * @memberof Invoice
     */
    'private'?: boolean;
    /**
     *  The index of this invoice. Each newly created invoice will increment this index making it monotonically increasing. CLN and LND handle ids differently. LND will generate an auto incremented integer id, while CLN will use a user supplied string id. To unify both, we auto generate an id for CLN and use the add_index for LND.  For `LND` this will be an `integer` in string form. This is auto generated by LND.  For `CLN` this will be a `string`. If the invoice was generated by BlitzAPI, this will be a [Firebase-like PushID](https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68). If generated by some other method, it\'ll be the string supplied by the user at the time of creation of the invoice. 
     * @type {string}
     * @memberof Invoice
     */
    'add_index': string;
    /**
     *          The \"settle\" index of this invoice. Each newly settled invoice will  increment this index making it monotonically increasing.     
     * @type {number}
     * @memberof Invoice
     */
    'settle_index'?: number;
    /**
     *      The amount that was accepted for this invoice, in satoshis. This     will ONLY be set if this invoice has been settled. We provide     this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted.     Additionally, it\'s possible that the sender paid MORE that     was specified in the original invoice. So we\'ll record that here as well.     
     * @type {number}
     * @memberof Invoice
     */
    'amt_paid_sat'?: number;
    /**
     *      The amount that was accepted for this invoice, in millisatoshis.     This will ONLY be set if this invoice has been settled. We     provide this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted. Additionally,     it\'s possible that the sender paid MORE that was specified in the     original invoice. So we\'ll record that here as well.     
     * @type {number}
     * @memberof Invoice
     */
    'amt_paid_msat'?: number;
    /**
     * The state the invoice is in.
     * @type {InvoiceState}
     * @memberof Invoice
     */
    'state': InvoiceState;
    /**
     * List of HTLCs paying to this invoice[EXPERIMENTAL].
     * @type {Array<InvoiceHTLC>}
     * @memberof Invoice
     */
    'htlcs'?: Array<InvoiceHTLC>;
    /**
     * List of features advertised on the invoice.
     * @type {Array<FeaturesEntry>}
     * @memberof Invoice
     */
    'features'?: Array<FeaturesEntry>;
    /**
     * [LND only] Indicates if this invoice was a spontaneous payment that arrived via keysend[EXPERIMENTAL].
     * @type {boolean}
     * @memberof Invoice
     */
    'is_keysend'?: boolean;
    /**
     *  The payment address of this invoice. This value will be used in MPP payments,     and also for newer invoices that always require the MPP payload for added end-to-end security.
     * @type {string}
     * @memberof Invoice
     */
    'payment_addr'?: string;
    /**
     * Signals whether or not this is an AMP invoice.
     * @type {boolean}
     * @memberof Invoice
     */
    'is_amp'?: boolean;
}
/**
 * 
 * @export
 * @interface InvoiceHTLC
 */
export interface InvoiceHTLC {
    /**
     * The channel ID over which the HTLC was received.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'chan_id': number;
    /**
     * The index of the HTLC on the channel.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'htlc_index': number;
    /**
     * The amount of the HTLC in msat.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'amt_msat': number;
    /**
     * The block height at which this HTLC was accepted.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'accept_height': number;
    /**
     * The time at which this HTLC was accepted.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'accept_time': number;
    /**
     * The time at which this HTLC was resolved.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'resolve_time': number;
    /**
     * The block height at which this HTLC expires.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'expiry_height': number;
    /**
     * The state of the HTLC.
     * @type {InvoiceHTLCState}
     * @memberof InvoiceHTLC
     */
    'state': InvoiceHTLCState;
    /**
     * Custom tlv records.
     * @type {Array<CustomRecordsEntry>}
     * @memberof InvoiceHTLC
     */
    'custom_records'?: Array<CustomRecordsEntry>;
    /**
     * The total amount of the mpp payment in msat.
     * @type {number}
     * @memberof InvoiceHTLC
     */
    'mpp_total_amt_msat': number;
    /**
     * 
     * @type {Amp}
     * @memberof InvoiceHTLC
     */
    'amp'?: Amp;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const InvoiceHTLCState = {
    Accepted: 'accepted',
    Settled: 'settled',
    Canceled: 'canceled'
} as const;

export type InvoiceHTLCState = typeof InvoiceHTLCState[keyof typeof InvoiceHTLCState];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const InvoiceState = {
    Open: 'open',
    Settled: 'settled',
    Canceled: 'canceled',
    Accepted: 'accepted'
} as const;

export type InvoiceState = typeof InvoiceState[keyof typeof InvoiceState];


/**
 * 
 * @export
 * @interface LightningInfoLite
 */
export interface LightningInfoLite {
    /**
     * Lightning software implementation (LND, c-lightning)
     * @type {string}
     * @memberof LightningInfoLite
     */
    'implementation': string;
    /**
     * Version of the implementation
     * @type {string}
     * @memberof LightningInfoLite
     */
    'version': string;
    /**
     * The identity pubkey of the current node
     * @type {string}
     * @memberof LightningInfoLite
     */
    'identity_pubkey': string;
    /**
     * Number of pending channels
     * @type {number}
     * @memberof LightningInfoLite
     */
    'num_pending_channels': number;
    /**
     * Number of active channels
     * @type {number}
     * @memberof LightningInfoLite
     */
    'num_active_channels': number;
    /**
     * Number of inactive channels
     * @type {number}
     * @memberof LightningInfoLite
     */
    'num_inactive_channels': number;
    /**
     * Number of peers
     * @type {number}
     * @memberof LightningInfoLite
     */
    'num_peers': number;
    /**
     * The node\'s current view of the height of the best block
     * @type {number}
     * @memberof LightningInfoLite
     */
    'block_height': number;
    /**
     * Whether the wallet\'s view is synced to the main chain
     * @type {boolean}
     * @memberof LightningInfoLite
     */
    'synced_to_chain'?: boolean;
    /**
     * Whether we consider ourselves synced with the public channel graph.
     * @type {boolean}
     * @memberof LightningInfoLite
     */
    'synced_to_graph'?: boolean;
}
/**
 * 
 * @export
 * @interface LnInfo
 */
export interface LnInfo {
    /**
     * Lightning software implementation (LND, CLN)
     * @type {string}
     * @memberof LnInfo
     */
    'implementation': string;
    /**
     * The version of the software that the node is running.
     * @type {string}
     * @memberof LnInfo
     */
    'version': string;
    /**
     * The SHA1 commit hash that the daemon is compiled with.
     * @type {string}
     * @memberof LnInfo
     */
    'commit_hash': string;
    /**
     * 
     * @type {string}
     * @memberof LnInfo
     */
    'identity_pubkey'?: string;
    /**
     * 
     * @type {string}
     * @memberof LnInfo
     */
    'identity_uri'?: string;
    /**
     * The alias of the node.
     * @type {string}
     * @memberof LnInfo
     */
    'alias': string;
    /**
     * The color of the current node in hex code format.
     * @type {string}
     * @memberof LnInfo
     */
    'color': string;
    /**
     * Number of pending channels.
     * @type {number}
     * @memberof LnInfo
     */
    'num_pending_channels': number;
    /**
     * Number of active channels.
     * @type {number}
     * @memberof LnInfo
     */
    'num_active_channels': number;
    /**
     * Number of inactive channels.
     * @type {number}
     * @memberof LnInfo
     */
    'num_inactive_channels': number;
    /**
     * Number of peers.
     * @type {number}
     * @memberof LnInfo
     */
    'num_peers': number;
    /**
     * The node\'s current view of the height of the best block. Only available with LND.
     * @type {number}
     * @memberof LnInfo
     */
    'block_height': number;
    /**
     * The node\'s current view of the hash of the best block. Only available with LND.
     * @type {string}
     * @memberof LnInfo
     */
    'block_hash'?: string;
    /**
     * Timestamp of the block best known to the wallet. Only available with LND.
     * @type {number}
     * @memberof LnInfo
     */
    'best_header_timestamp'?: number;
    /**
     * Whether the wallet\'s view is synced to the main chain. Only available with LND.
     * @type {boolean}
     * @memberof LnInfo
     */
    'synced_to_chain'?: boolean;
    /**
     * Whether we consider ourselves synced with the public channel graph. Only available with LND.
     * @type {boolean}
     * @memberof LnInfo
     */
    'synced_to_graph'?: boolean;
    /**
     * A list of active chains the node is connected to
     * @type {Array<Chain>}
     * @memberof LnInfo
     */
    'chains'?: Array<Chain>;
    /**
     * The URIs of the current node.
     * @type {Array<string>}
     * @memberof LnInfo
     */
    'uris'?: Array<string>;
    /**
     * Features that our node has advertised in our init message node announcements and invoices. Not yet implemented with CLN
     * @type {Array<FeaturesEntry>}
     * @memberof LnInfo
     */
    'features'?: Array<FeaturesEntry>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface LoginInput
 */
export interface LoginInput {
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'one_time_password'?: string;
}
/**
 * 
 * @export
 * @interface MPPRecord
 */
export interface MPPRecord {
    /**
     * 
     * @type {string}
     * @memberof MPPRecord
     */
    'payment_addr': string;
    /**
     * 
     * @type {number}
     * @memberof MPPRecord
     */
    'total_amt_msat': number;
}
/**
 * 
 * @export
 * @interface NetworkInfo
 */
export interface NetworkInfo {
    /**
     * The bitcoin core server version
     * @type {number}
     * @memberof NetworkInfo
     */
    'version': number;
    /**
     * The server subversion string
     * @type {string}
     * @memberof NetworkInfo
     */
    'subversion': string;
    /**
     * The protocol version
     * @type {number}
     * @memberof NetworkInfo
     */
    'protocol_version': number;
    /**
     * The services we offer to the network, hex formatted
     * @type {string}
     * @memberof NetworkInfo
     */
    'local_services'?: string;
    /**
     * The services we offer to the network, in human-readable form
     * @type {Array<string>}
     * @memberof NetworkInfo
     */
    'local_services_names'?: Array<string>;
    /**
     * True if transaction relay is requested from peers
     * @type {boolean}
     * @memberof NetworkInfo
     */
    'local_relay': boolean;
    /**
     * The time offset
     * @type {number}
     * @memberof NetworkInfo
     */
    'time_offset': number;
    /**
     * The total number of connections
     * @type {number}
     * @memberof NetworkInfo
     */
    'connections': number;
    /**
     * The number of inbound connections
     * @type {number}
     * @memberof NetworkInfo
     */
    'connections_in': number;
    /**
     * The number of outbound connections
     * @type {number}
     * @memberof NetworkInfo
     */
    'connections_out': number;
    /**
     * Whether p2p networking is enabled
     * @type {boolean}
     * @memberof NetworkInfo
     */
    'network_active': boolean;
    /**
     * Information per network
     * @type {Array<BtcNetwork>}
     * @memberof NetworkInfo
     */
    'networks': Array<BtcNetwork>;
    /**
     * Minimum relay fee for transactions in BTC/kB
     * @type {number}
     * @memberof NetworkInfo
     */
    'relay_fee': number;
    /**
     * Minimum fee increment for mempool limiting or BIP 125 replacement in BTC/kB
     * @type {number}
     * @memberof NetworkInfo
     */
    'incremental_fee': number;
    /**
     * List of local addresses
     * @type {Array<BtcLocalAddress>}
     * @memberof NetworkInfo
     */
    'local_addresses'?: Array<BtcLocalAddress>;
    /**
     * Any network and blockchain warnings
     * @type {string}
     * @memberof NetworkInfo
     */
    'warnings'?: string;
}
/**
 * 
 * @export
 * @interface NewAddressInput
 */
export interface NewAddressInput {
    /**
     *  Address-types has to be one of: * p2wkh:  Pay to witness key hash (bech32) * np2wkh: Pay to nested witness key hash     
     * @type {OnchainAddressType}
     * @memberof NewAddressInput
     */
    'type': OnchainAddressType;
}
/**
 * 
 * @export
 * @interface OnChainTransaction
 */
export interface OnChainTransaction {
    /**
     * The transaction hash
     * @type {string}
     * @memberof OnChainTransaction
     */
    'tx_hash': string;
    /**
     * The transaction amount, denominated in satoshis
     * @type {number}
     * @memberof OnChainTransaction
     */
    'amount': number;
    /**
     * The number of confirmations
     * @type {number}
     * @memberof OnChainTransaction
     */
    'num_confirmations': number;
    /**
     * The height of the block this transaction was included in
     * @type {number}
     * @memberof OnChainTransaction
     */
    'block_height': number;
    /**
     * Timestamp of this transaction
     * @type {number}
     * @memberof OnChainTransaction
     */
    'time_stamp': number;
    /**
     * Fees paid for this transaction
     * @type {number}
     * @memberof OnChainTransaction
     */
    'total_fees': number;
    /**
     * Addresses that received funds for this transaction
     * @type {Array<string>}
     * @memberof OnChainTransaction
     */
    'dest_addresses'?: Array<string>;
    /**
     * An optional label that was set on transaction broadcast.
     * @type {string}
     * @memberof OnChainTransaction
     */
    'label'?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const OnchainAddressType = {
    P2wkh: 'p2wkh',
    Np2wkh: 'np2wkh'
} as const;

export type OnchainAddressType = typeof OnchainAddressType[keyof typeof OnchainAddressType];


/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The payment hash
     * @type {string}
     * @memberof Payment
     */
    'payment_hash': string;
    /**
     * The payment preimage
     * @type {string}
     * @memberof Payment
     */
    'payment_preimage'?: string;
    /**
     * The value of the payment in milli-satoshis
     * @type {number}
     * @memberof Payment
     */
    'value_msat': number;
    /**
     * The optional payment request being fulfilled.
     * @type {string}
     * @memberof Payment
     */
    'payment_request'?: string;
    /**
     * The status of the payment.
     * @type {PaymentStatus}
     * @memberof Payment
     */
    'status'?: PaymentStatus;
    /**
     * The fee paid for this payment in msat
     * @type {number}
     * @memberof Payment
     */
    'fee_msat': number;
    /**
     * The time in UNIX nanoseconds at which the payment was created.
     * @type {number}
     * @memberof Payment
     */
    'creation_time_ns': number;
    /**
     * The HTLCs made in attempt to settle the payment.
     * @type {Array<HTLCAttempt>}
     * @memberof Payment
     */
    'htlcs'?: Array<HTLCAttempt>;
    /**
     * The payment index. Only set with LND, 0 otherwise.
     * @type {number}
     * @memberof Payment
     */
    'payment_index'?: number;
    /**
     * The payment label. Only set with CLN, empty otherwise.
     * @type {string}
     * @memberof Payment
     */
    'label'?: string;
    /**
     * The failure reason
     * @type {PaymentFailureReason}
     * @memberof Payment
     */
    'failure_reason'?: PaymentFailureReason;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PaymentFailureReason = {
    None: 'FAILURE_REASON_NONE',
    Timeout: 'FAILURE_REASON_TIMEOUT',
    NoRoute: 'FAILURE_REASON_NO_ROUTE',
    Error: 'FAILURE_REASON_ERROR',
    IncorrectPaymentDetails: 'FAILURE_REASON_INCORRECT_PAYMENT_DETAILS',
    InsufficientBalance: 'FAILURE_REASON_INSUFFICIENT_BALANCE'
} as const;

export type PaymentFailureReason = typeof PaymentFailureReason[keyof typeof PaymentFailureReason];


/**
 * 
 * @export
 * @interface PaymentRequest
 */
export interface PaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentRequest
     */
    'destination': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRequest
     */
    'payment_hash': string;
    /**
     * Deprecated. User num_msat instead
     * @type {number}
     * @memberof PaymentRequest
     */
    'num_satoshis'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequest
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequest
     */
    'expiry': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRequest
     */
    'description_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRequest
     */
    'fallback_addr'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequest
     */
    'cltv_expiry': number;
    /**
     * A list of [HopHint] for the RouteHint
     * @type {Array<RouteHint>}
     * @memberof PaymentRequest
     */
    'route_hints'?: Array<RouteHint>;
    /**
     * The payment address in hex format
     * @type {string}
     * @memberof PaymentRequest
     */
    'payment_addr'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequest
     */
    'num_msat'?: number;
    /**
     * 
     * @type {Array<FeaturesEntry>}
     * @memberof PaymentRequest
     */
    'features'?: Array<FeaturesEntry>;
    /**
     * Optional requested currency of the payment. 
     * @type {string}
     * @memberof PaymentRequest
     */
    'currency'?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Unknown: 'unknown',
    InFlight: 'in_flight',
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 
 * @export
 * @interface RawDebugLogData
 */
export interface RawDebugLogData {
    /**
     * The raw debug log text
     * @type {string}
     * @memberof RawDebugLogData
     */
    'raw_data': string;
    /**
     * Link to the Raspiblitz issue tracker
     * @type {string}
     * @memberof RawDebugLogData
     */
    'github_issues_url'?: string;
}
/**
 * 
 * @export
 * @interface Route
 */
export interface Route {
    /**
     * 
     * @type {number}
     * @memberof Route
     */
    'total_time_lock': number;
    /**
     * 
     * @type {number}
     * @memberof Route
     */
    'total_fees': number;
    /**
     * 
     * @type {number}
     * @memberof Route
     */
    'total_amt': number;
    /**
     * 
     * @type {Array<Hop>}
     * @memberof Route
     */
    'hops': Array<Hop>;
    /**
     * 
     * @type {number}
     * @memberof Route
     */
    'total_fees_msat': number;
    /**
     * 
     * @type {number}
     * @memberof Route
     */
    'total_amt_msat': number;
    /**
     * 
     * @type {MPPRecord}
     * @memberof Route
     */
    'mpp_record'?: MPPRecord;
    /**
     * 
     * @type {AMPRecord}
     * @memberof Route
     */
    'amp_record'?: AMPRecord;
    /**
     * 
     * @type {Array<CustomRecordsEntry>}
     * @memberof Route
     */
    'custom_records': Array<CustomRecordsEntry>;
}
/**
 * 
 * @export
 * @interface RouteHint
 */
export interface RouteHint {
    /**
     * A list of hop hints that when chained together can assist in reaching a specific destination.
     * @type {Array<HopHint>}
     * @memberof RouteHint
     */
    'hop_hints'?: Array<HopHint>;
}
/**
 * 
 * @export
 * @interface SendCoinsInput
 */
export interface SendCoinsInput {
    /**
     * The base58 or bech32 encoded bitcoin address to send coins to on-chain
     * @type {string}
     * @memberof SendCoinsInput
     */
    'address': string;
    /**
     * The number of bitcoin denominated in satoshis to send
     * @type {number}
     * @memberof SendCoinsInput
     */
    'amount': number;
    /**
     * The number of blocks that the transaction *should* confirm in, will be used for fee estimation
     * @type {number}
     * @memberof SendCoinsInput
     */
    'target_conf'?: number;
    /**
     * A manual fee expressed in sat/vbyte that should be used when crafting the transaction (default: 0)
     * @type {number}
     * @memberof SendCoinsInput
     */
    'sat_per_vbyte'?: number;
    /**
     * The minimum number of confirmations each one of your outputs used for the transaction must satisfy
     * @type {number}
     * @memberof SendCoinsInput
     */
    'min_confs'?: number;
    /**
     * A label for the transaction. Ignored by CLN backend.
     * @type {string}
     * @memberof SendCoinsInput
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface SendCoinsResponse
 */
export interface SendCoinsResponse {
    /**
     * The transaction ID for this onchain payment
     * @type {string}
     * @memberof SendCoinsResponse
     */
    'txid': string;
    /**
     * The base58 or bech32 encoded bitcoin address where the onchain funds where sent to
     * @type {string}
     * @memberof SendCoinsResponse
     */
    'address': string;
    /**
     * The number of bitcoin denominated in satoshis which where sent
     * @type {number}
     * @memberof SendCoinsResponse
     */
    'amount': number;
    /**
     * The label used for the transaction. Ignored by CLN backend.
     * @type {string}
     * @memberof SendCoinsResponse
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface SoftFork
 */
export interface SoftFork {
    /**
     * Name of the softfork
     * @type {string}
     * @memberof SoftFork
     */
    'name': string;
    /**
     * One of \"buried\", \"bip9\"
     * @type {string}
     * @memberof SoftFork
     */
    'type': string;
    /**
     * True **if** the rules are enforced for the mempool and the next block
     * @type {boolean}
     * @memberof SoftFork
     */
    'active': boolean;
    /**
     * 
     * @type {Bip9}
     * @memberof SoftFork
     */
    'bip9'?: Bip9;
    /**
     * Height of the first block which the rules are or will be enforced (only for `buried` type, or `bip9` type with `active` status)
     * @type {number}
     * @memberof SoftFork
     */
    'height'?: number;
}
/**
 * 
 * @export
 * @interface StartDoneData
 */
export interface StartDoneData {
    /**
     * 
     * @type {string}
     * @memberof StartDoneData
     */
    'hostname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StartDoneData
     */
    'forceFreshSetup'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StartDoneData
     */
    'keepBlockchain'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StartDoneData
     */
    'lightning'?: string;
    /**
     * 
     * @type {string}
     * @memberof StartDoneData
     */
    'passwordA'?: string;
    /**
     * 
     * @type {string}
     * @memberof StartDoneData
     */
    'passwordB'?: string;
    /**
     * 
     * @type {string}
     * @memberof StartDoneData
     */
    'passwordC'?: string;
}
/**
 * numeric statistics about BIP9 signalling for a softfork(only for `started` status)
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * The length in blocks of the BIP9 signalling period
     * @type {number}
     * @memberof Statistics
     */
    'period': number;
    /**
     * The number of blocks with the version bit set required to activate the feature
     * @type {number}
     * @memberof Statistics
     */
    'threshold': number;
    /**
     * The number of blocks elapsed since the beginning of the current period
     * @type {number}
     * @memberof Statistics
     */
    'elapsed': number;
    /**
     * The number of blocks with the version bit set in the current period
     * @type {number}
     * @memberof Statistics
     */
    'count': number;
    /**
     * False if there are not enough blocks left in this period to pass activation threshold
     * @type {boolean}
     * @memberof Statistics
     */
    'possible': boolean;
}
/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * Name of the node (same as Lightning alias)
     * @type {string}
     * @memberof SystemInfo
     */
    'alias'?: string;
    /**
     * The color of the current node in hex code format
     * @type {string}
     * @memberof SystemInfo
     */
    'color': string;
    /**
     * The platform this API is running on.
     * @type {APIPlatform}
     * @memberof SystemInfo
     */
    'platform'?: APIPlatform;
    /**
     * The version of this platform
     * @type {string}
     * @memberof SystemInfo
     */
    'platform_version'?: string;
    /**
     * Version of the API software on this system.
     * @type {string}
     * @memberof SystemInfo
     */
    'api_version': string;
    /**
     * WebUI TOR address
     * @type {string}
     * @memberof SystemInfo
     */
    'tor_web_ui'?: string;
    /**
     * API TOR address
     * @type {string}
     * @memberof SystemInfo
     */
    'tor_api'?: string;
    /**
     * WebUI LAN address
     * @type {string}
     * @memberof SystemInfo
     */
    'lan_web_ui'?: string;
    /**
     * API LAN address
     * @type {string}
     * @memberof SystemInfo
     */
    'lan_api'?: string;
    /**
     * Address to ssh into on local LAN (e.g. `ssh admin@192.168.1.28`
     * @type {string}
     * @memberof SystemInfo
     */
    'ssh_address': string;
    /**
     * The current chain this node is connected to (mainnet, testnet or signet)
     * @type {string}
     * @memberof SystemInfo
     */
    'chain': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TxCategory = {
    Onchain: 'onchain',
    Ln: 'ln'
} as const;

export type TxCategory = typeof TxCategory[keyof typeof TxCategory];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TxStatus = {
    Unknown: 'unknown',
    InFlight: 'in_flight',
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type TxStatus = typeof TxStatus[keyof typeof TxStatus];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TxType = {
    Unknown: 'unknown',
    Send: 'send',
    Receive: 'receive'
} as const;

export type TxType = typeof TxType[keyof typeof TxType];


/**
 * 
 * @export
 * @interface UninstallData
 */
export interface UninstallData {
    /**
     * 
     * @type {boolean}
     * @memberof UninstallData
     */
    'keepData'?: boolean;
}
/**
 * 
 * @export
 * @interface UnlockWalletInput
 */
export interface UnlockWalletInput {
    /**
     * The wallet password
     * @type {string}
     * @memberof UnlockWalletInput
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface WalletBalance
 */
export interface WalletBalance {
    /**
     * Confirmed onchain balance (more than three confirmations) in sat
     * @type {number}
     * @memberof WalletBalance
     */
    'onchain_confirmed_balance': number;
    /**
     * Total combined onchain balance in sat
     * @type {number}
     * @memberof WalletBalance
     */
    'onchain_total_balance': number;
    /**
     * Unconfirmed onchain balance (less than three confirmations) in sat
     * @type {number}
     * @memberof WalletBalance
     */
    'onchain_unconfirmed_balance': number;
    /**
     * Sum of channels local balances in msat
     * @type {number}
     * @memberof WalletBalance
     */
    'channel_local_balance': number;
    /**
     * Sum of channels remote balances in msat.
     * @type {number}
     * @memberof WalletBalance
     */
    'channel_remote_balance': number;
    /**
     * Sum of channels local unsettled balances in msat.
     * @type {number}
     * @memberof WalletBalance
     */
    'channel_unsettled_local_balance': number;
    /**
     * Sum of channels remote unsettled balances in msat.
     * @type {number}
     * @memberof WalletBalance
     */
    'channel_unsettled_remote_balance': number;
    /**
     * Sum of channels pending local balances in msat.
     * @type {number}
     * @memberof WalletBalance
     */
    'channel_pending_open_local_balance': number;
    /**
     * Sum of channels pending remote balances in msat.
     * @type {number}
     * @memberof WalletBalance
     */
    'channel_pending_open_remote_balance': number;
}

/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Install app
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsInstallAppsInstallNamePost: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('appsInstallAppsInstallNamePost', 'name', name)
            const localVarPath = `/apps/install/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstall app
         * @param {string} name 
         * @param {UninstallData} uninstallData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsInstallAppsUninstallNamePost: async (name: string, uninstallData: UninstallData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('appsInstallAppsUninstallNamePost', 'name', name)
            // verify required parameter 'uninstallData' is not null or undefined
            assertParamExists('appsInstallAppsUninstallNamePost', 'uninstallData', uninstallData)
            const localVarPath = `/apps/uninstall/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uninstallData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status available apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsStatusAppsStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of a single app by id.
         * @param {any} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsStatusAppsStatusIdGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appsStatusAppsStatusIdGet', 'id', id)
            const localVarPath = `/apps/status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe to status changes of currently installed apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsStatusSubAppsStatusSubGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps/status-sub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Install app
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsInstallAppsInstallNamePost(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsInstallAppsInstallNamePost(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Uninstall app
         * @param {string} name 
         * @param {UninstallData} uninstallData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsInstallAppsUninstallNamePost(name: string, uninstallData: UninstallData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsInstallAppsUninstallNamePost(name, uninstallData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the status available apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsStatusAppsStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsStatusAppsStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the status of a single app by id.
         * @param {any} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsStatusAppsStatusIdGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsStatusAppsStatusIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Subscribe to status changes of currently installed apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsStatusSubAppsStatusSubGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsStatusSubAppsStatusSubGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * 
         * @summary Install app
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsInstallAppsInstallNamePost(name: string, options?: any): AxiosPromise<any> {
            return localVarFp.appsInstallAppsInstallNamePost(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstall app
         * @param {string} name 
         * @param {UninstallData} uninstallData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsInstallAppsUninstallNamePost(name: string, uninstallData: UninstallData, options?: any): AxiosPromise<any> {
            return localVarFp.appsInstallAppsUninstallNamePost(name, uninstallData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status available apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsStatusAppsStatusGet(options?: any): AxiosPromise<any> {
            return localVarFp.appsStatusAppsStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of a single app by id.
         * @param {any} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsStatusAppsStatusIdGet(id: any, options?: any): AxiosPromise<any> {
            return localVarFp.appsStatusAppsStatusIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Subscribe to status changes of currently installed apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsStatusSubAppsStatusSubGet(options?: any): AxiosPromise<any> {
            return localVarFp.appsStatusSubAppsStatusSubGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * 
     * @summary Install app
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsInstallAppsInstallNamePost(name: string, options?: AxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsInstallAppsInstallNamePost(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstall app
     * @param {string} name 
     * @param {UninstallData} uninstallData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsInstallAppsUninstallNamePost(name: string, uninstallData: UninstallData, options?: AxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsInstallAppsUninstallNamePost(name, uninstallData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status available apps.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsStatusAppsStatusGet(options?: AxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsStatusAppsStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of a single app by id.
     * @param {any} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsStatusAppsStatusIdGet(id: any, options?: AxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsStatusAppsStatusIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Subscribe to status changes of currently installed apps.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsStatusSubAppsStatusSubGet(options?: AxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsStatusSubAppsStatusSubGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BitcoinCoreApi - axios parameter creator
 * @export
 */
export const BitcoinCoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Similar to Bitcoin Core getblock  SSE endpoint to receive new block information as soon as it is appended to chain.  If verbosity is 0, returns a string that is serialized, hex-encoded data for block \'hash\'.<br> If verbosity is 1, returns an Object with information about block <hash>.<br> If verbosity is 2, returns an Object with information about block <hash> and information about each transaction.<br> 
         * @summary Subscribe to incoming blocks.
         * @param {number} [verbosity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinBlockSubBitcoinBlockSubGet: async (verbosity?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bitcoin/block-sub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (verbosity !== undefined) {
                localVarQueryParameter['verbosity'] = verbosity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get general information about bitcoin core. Combines most important information from `getblockchaininfo` and `getnetworkinfo`
         * @summary Bitcoin.Btc-Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinBtcInfoBitcoinBtcInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bitcoin/btc-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimates the fee for the given parameters.     See documentation on [bitcoin.org](https://developer.bitcoin.org/reference/rpc/estimatesmartfee.html)     
         * @summary Get current fee estimation from Bitcoin Core
         * @param {number} [targetConf] Confirmation target in blocks.
         * @param {FeeEstimationMode} [mode] Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinEstimateFeeBitcoinEstimateFeeGet: async (targetConf?: number, mode?: FeeEstimationMode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bitcoin/estimate-fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (targetConf !== undefined) {
                localVarQueryParameter['target_conf'] = targetConf;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockcount/)
         * @summary Get the current block count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinGetBlockCountBitcoinGetBlockCountGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bitcoin/get-block-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockchaininfo/)
         * @summary Get the current blockchain status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinGetBlockchainInfoBitcoinGetBlockchainInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bitcoin/get-blockchain-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/network/getnetworkinfo/)
         * @summary Get information about the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinGetNetworkInfoBitcoinGetNetworkInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bitcoin/get-network-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BitcoinCoreApi - functional programming interface
 * @export
 */
export const BitcoinCoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BitcoinCoreApiAxiosParamCreator(configuration)
    return {
        /**
         *  Similar to Bitcoin Core getblock  SSE endpoint to receive new block information as soon as it is appended to chain.  If verbosity is 0, returns a string that is serialized, hex-encoded data for block \'hash\'.<br> If verbosity is 1, returns an Object with information about block <hash>.<br> If verbosity is 2, returns an Object with information about block <hash> and information about each transaction.<br> 
         * @summary Subscribe to incoming blocks.
         * @param {number} [verbosity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitcoinBlockSubBitcoinBlockSubGet(verbosity?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitcoinBlockSubBitcoinBlockSubGet(verbosity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get general information about bitcoin core. Combines most important information from `getblockchaininfo` and `getnetworkinfo`
         * @summary Bitcoin.Btc-Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitcoinBtcInfoBitcoinBtcInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtcInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitcoinBtcInfoBitcoinBtcInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Estimates the fee for the given parameters.     See documentation on [bitcoin.org](https://developer.bitcoin.org/reference/rpc/estimatesmartfee.html)     
         * @summary Get current fee estimation from Bitcoin Core
         * @param {number} [targetConf] Confirmation target in blocks.
         * @param {FeeEstimationMode} [mode] Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitcoinEstimateFeeBitcoinEstimateFeeGet(targetConf?: number, mode?: FeeEstimationMode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitcoinEstimateFeeBitcoinEstimateFeeGet(targetConf, mode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockcount/)
         * @summary Get the current block count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitcoinGetBlockCountBitcoinGetBlockCountGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitcoinGetBlockCountBitcoinGetBlockCountGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockchaininfo/)
         * @summary Get the current blockchain status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitcoinGetBlockchainInfoBitcoinGetBlockchainInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockchainInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitcoinGetBlockchainInfoBitcoinGetBlockchainInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/network/getnetworkinfo/)
         * @summary Get information about the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitcoinGetNetworkInfoBitcoinGetNetworkInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitcoinGetNetworkInfoBitcoinGetNetworkInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BitcoinCoreApi - factory interface
 * @export
 */
export const BitcoinCoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BitcoinCoreApiFp(configuration)
    return {
        /**
         *  Similar to Bitcoin Core getblock  SSE endpoint to receive new block information as soon as it is appended to chain.  If verbosity is 0, returns a string that is serialized, hex-encoded data for block \'hash\'.<br> If verbosity is 1, returns an Object with information about block <hash>.<br> If verbosity is 2, returns an Object with information about block <hash> and information about each transaction.<br> 
         * @summary Subscribe to incoming blocks.
         * @param {number} [verbosity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinBlockSubBitcoinBlockSubGet(verbosity?: number, options?: any): AxiosPromise<any> {
            return localVarFp.bitcoinBlockSubBitcoinBlockSubGet(verbosity, options).then((request) => request(axios, basePath));
        },
        /**
         * Get general information about bitcoin core. Combines most important information from `getblockchaininfo` and `getnetworkinfo`
         * @summary Bitcoin.Btc-Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinBtcInfoBitcoinBtcInfoGet(options?: any): AxiosPromise<BtcInfo> {
            return localVarFp.bitcoinBtcInfoBitcoinBtcInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Estimates the fee for the given parameters.     See documentation on [bitcoin.org](https://developer.bitcoin.org/reference/rpc/estimatesmartfee.html)     
         * @summary Get current fee estimation from Bitcoin Core
         * @param {number} [targetConf] Confirmation target in blocks.
         * @param {FeeEstimationMode} [mode] Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinEstimateFeeBitcoinEstimateFeeGet(targetConf?: number, mode?: FeeEstimationMode, options?: any): AxiosPromise<number> {
            return localVarFp.bitcoinEstimateFeeBitcoinEstimateFeeGet(targetConf, mode, options).then((request) => request(axios, basePath));
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockcount/)
         * @summary Get the current block count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinGetBlockCountBitcoinGetBlockCountGet(options?: any): AxiosPromise<any> {
            return localVarFp.bitcoinGetBlockCountBitcoinGetBlockCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockchaininfo/)
         * @summary Get the current blockchain status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinGetBlockchainInfoBitcoinGetBlockchainInfoGet(options?: any): AxiosPromise<BlockchainInfo> {
            return localVarFp.bitcoinGetBlockchainInfoBitcoinGetBlockchainInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/network/getnetworkinfo/)
         * @summary Get information about the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitcoinGetNetworkInfoBitcoinGetNetworkInfoGet(options?: any): AxiosPromise<NetworkInfo> {
            return localVarFp.bitcoinGetNetworkInfoBitcoinGetNetworkInfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BitcoinCoreApi - object-oriented interface
 * @export
 * @class BitcoinCoreApi
 * @extends {BaseAPI}
 */
export class BitcoinCoreApi extends BaseAPI {
    /**
     *  Similar to Bitcoin Core getblock  SSE endpoint to receive new block information as soon as it is appended to chain.  If verbosity is 0, returns a string that is serialized, hex-encoded data for block \'hash\'.<br> If verbosity is 1, returns an Object with information about block <hash>.<br> If verbosity is 2, returns an Object with information about block <hash> and information about each transaction.<br> 
     * @summary Subscribe to incoming blocks.
     * @param {number} [verbosity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinCoreApi
     */
    public bitcoinBlockSubBitcoinBlockSubGet(verbosity?: number, options?: AxiosRequestConfig) {
        return BitcoinCoreApiFp(this.configuration).bitcoinBlockSubBitcoinBlockSubGet(verbosity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get general information about bitcoin core. Combines most important information from `getblockchaininfo` and `getnetworkinfo`
     * @summary Bitcoin.Btc-Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinCoreApi
     */
    public bitcoinBtcInfoBitcoinBtcInfoGet(options?: AxiosRequestConfig) {
        return BitcoinCoreApiFp(this.configuration).bitcoinBtcInfoBitcoinBtcInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Estimates the fee for the given parameters.     See documentation on [bitcoin.org](https://developer.bitcoin.org/reference/rpc/estimatesmartfee.html)     
     * @summary Get current fee estimation from Bitcoin Core
     * @param {number} [targetConf] Confirmation target in blocks.
     * @param {FeeEstimationMode} [mode] Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinCoreApi
     */
    public bitcoinEstimateFeeBitcoinEstimateFeeGet(targetConf?: number, mode?: FeeEstimationMode, options?: AxiosRequestConfig) {
        return BitcoinCoreApiFp(this.configuration).bitcoinEstimateFeeBitcoinEstimateFeeGet(targetConf, mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockcount/)
     * @summary Get the current block count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinCoreApi
     */
    public bitcoinGetBlockCountBitcoinGetBlockCountGet(options?: AxiosRequestConfig) {
        return BitcoinCoreApiFp(this.configuration).bitcoinGetBlockCountBitcoinGetBlockCountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/getblockchaininfo/)
     * @summary Get the current blockchain status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinCoreApi
     */
    public bitcoinGetBlockchainInfoBitcoinGetBlockchainInfoGet(options?: AxiosRequestConfig) {
        return BitcoinCoreApiFp(this.configuration).bitcoinGetBlockchainInfoBitcoinGetBlockchainInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * See documentation on [bitcoincore.org](https://bitcoincore.org/en/doc/0.21.0/rpc/network/getnetworkinfo/)
     * @summary Get information about the network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitcoinCoreApi
     */
    public bitcoinGetNetworkInfoBitcoinGetNetworkInfoGet(options?: AxiosRequestConfig) {
        return BitcoinCoreApiFp(this.configuration).bitcoinGetNetworkInfoBitcoinGetNetworkInfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LightningApi - axios parameter creator
 * @export
 */
export const LightningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
         * @summary Addinvoice adds a new Invoice to the database.
         * @param {number} valueMsat 
         * @param {string} [memo] 
         * @param {number} [expiry] 
         * @param {boolean} [isKeysend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningAddInvoiceLightningAddInvoicePost: async (valueMsat: number, memo?: string, expiry?: number, isKeysend?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'valueMsat' is not null or undefined
            assertParamExists('lightningAddInvoiceLightningAddInvoicePost', 'valueMsat', valueMsat)
            const localVarPath = `/lightning/add-invoice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (valueMsat !== undefined) {
                localVarQueryParameter['value_msat'] = valueMsat;
            }

            if (memo !== undefined) {
                localVarQueryParameter['memo'] = memo;
            }

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }

            if (isKeysend !== undefined) {
                localVarQueryParameter['is_keysend'] = isKeysend;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For additional information see [LND docs](https://api.lightning.community/#closechannel)
         * @summary close a channel
         * @param {string} channelId 
         * @param {boolean} forceClose 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningCloseChannelLightningCloseChannelPost: async (channelId: string, forceClose: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('lightningCloseChannelLightningCloseChannelPost', 'channelId', channelId)
            // verify required parameter 'forceClose' is not null or undefined
            assertParamExists('lightningCloseChannelLightningCloseChannelPost', 'forceClose', forceClose)
            const localVarPath = `/lightning/close-channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (forceClose !== undefined) {
                localVarQueryParameter['force_close'] = forceClose;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
         * @param {string} payReq The payment request string to be decoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningDecodePayReqLightningDecodePayReqGet: async (payReq: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payReq' is not null or undefined
            assertParamExists('lightningDecodePayReqLightningDecodePayReqGet', 'payReq', payReq)
            const localVarPath = `/lightning/decode-pay-req`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (payReq !== undefined) {
                localVarQueryParameter['pay_req'] = payReq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current on chain and channel balances of the lighting wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetBalanceLightningGetBalanceGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/get-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Currently, year and total fees are always null. Backends don\'t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
         * @summary Returns the daily, weekly and monthly fee revenue earned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetFeeRevenueLightningGetFeeRevenueGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/get-fee-revenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request information about the currently running lightning node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetInfoLightningGetInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/get-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get lightweight current lightning info. Less verbose version of /lightning/get-info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetInfoLiteLightningGetInfoLiteGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/get-info-lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
         * @summary Lists all on-chain transactions, payments and invoices in the wallet
         * @param {boolean} [successfulOnly] If set, only successful transaction will be returned in the response.
         * @param {number} [indexOffset] The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response.
         * @param {number} [maxTx] The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null.
         * @param {boolean} [reversed] If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListAllTxLightningListAllTxGet: async (successfulOnly?: boolean, indexOffset?: number, maxTx?: number, reversed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/list-all-tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (successfulOnly !== undefined) {
                localVarQueryParameter['successful_only'] = successfulOnly;
            }

            if (indexOffset !== undefined) {
                localVarQueryParameter['index_offset'] = indexOffset;
            }

            if (maxTx !== undefined) {
                localVarQueryParameter['max_tx'] = maxTx;
            }

            if (reversed !== undefined) {
                localVarQueryParameter['reversed'] = reversed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of open channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListChannelsLightningListChannelsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/list-channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all invoices from the wallet. Modeled after LND implementation.
         * @param {boolean} [pendingOnly] If set, only invoices that are not settled and not canceled will be returned in the response.
         * @param {number} [indexOffset] The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response.
         * @param {number} [numMaxInvoices] The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null.
         * @param {boolean} [reversed] If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListInvoicesLightningListInvoicesGet: async (pendingOnly?: boolean, indexOffset?: number, numMaxInvoices?: number, reversed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/list-invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pendingOnly !== undefined) {
                localVarQueryParameter['pending_only'] = pendingOnly;
            }

            if (indexOffset !== undefined) {
                localVarQueryParameter['index_offset'] = indexOffset;
            }

            if (numMaxInvoices !== undefined) {
                localVarQueryParameter['num_max_invoices'] = numMaxInvoices;
            }

            if (reversed !== undefined) {
                localVarQueryParameter['reversed'] = reversed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all onchain transactions from the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListOnchainTxLightningListOnchainTxGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/list-onchain-tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all outgoing payments. Modeled after LND implementation.
         * @param {boolean} [includeIncomplete] If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn\&#39;t change the meaning of the indices, which are tied to individual payments.
         * @param {number} [indexOffset] The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards.
         * @param {number} [maxPayments] The maximal number of payments returned in the response to this query.
         * @param {boolean} [reversed] If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListPaymentsLightningListPaymentsGet: async (includeIncomplete?: boolean, indexOffset?: number, maxPayments?: number, reversed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lightning/list-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeIncomplete !== undefined) {
                localVarQueryParameter['include_incomplete'] = includeIncomplete;
            }

            if (indexOffset !== undefined) {
                localVarQueryParameter['index_offset'] = indexOffset;
            }

            if (maxPayments !== undefined) {
                localVarQueryParameter['max_payments'] = maxPayments;
            }

            if (reversed !== undefined) {
                localVarQueryParameter['reversed'] = reversed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
         * @summary Generate a new on-chain address
         * @param {NewAddressInput} newAddressInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningNewAddressLightningNewAddressPost: async (newAddressInput: NewAddressInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newAddressInput' is not null or undefined
            assertParamExists('lightningNewAddressLightningNewAddressPost', 'newAddressInput', newAddressInput)
            const localVarPath = `/lightning/new-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newAddressInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ ==1: interpreted as urgent (aim for next block) * Set _target_conf_ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ >=10: interpreted as slow (next 100 blocks or so)  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
         * @summary open a new lightning channel
         * @param {number} localFundingAmount 
         * @param {string} nodeURI 
         * @param {number} [targetConfs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningOpenChannelLightningOpenChannelPost: async (localFundingAmount: number, nodeURI: string, targetConfs?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localFundingAmount' is not null or undefined
            assertParamExists('lightningOpenChannelLightningOpenChannelPost', 'localFundingAmount', localFundingAmount)
            // verify required parameter 'nodeURI' is not null or undefined
            assertParamExists('lightningOpenChannelLightningOpenChannelPost', 'nodeURI', nodeURI)
            const localVarPath = `/lightning/open-channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (localFundingAmount !== undefined) {
                localVarQueryParameter['local_funding_amount'] = localFundingAmount;
            }

            if (nodeURI !== undefined) {
                localVarQueryParameter['node_URI'] = nodeURI;
            }

            if (targetConfs !== undefined) {
                localVarQueryParameter['target_confs'] = targetConfs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  >  See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ ==1: interpreted as urgent (aim for next block) * Set __target_conf__ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ >=10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
         * @summary Attempt to send on-chain funds.
         * @param {SendCoinsInput} sendCoinsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningSendCoinsLightningSendCoinsPost: async (sendCoinsInput: SendCoinsInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendCoinsInput' is not null or undefined
            assertParamExists('lightningSendCoinsLightningSendCoinsPost', 'sendCoinsInput', sendCoinsInput)
            const localVarPath = `/lightning/send-coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendCoinsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
         * @summary Attempt to pay a payment request.
         * @param {string} payReq 
         * @param {number} [timeoutSeconds] 
         * @param {number} [feeLimitMsat] 
         * @param {number} [amountMsat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningSendPaymentLightningSendPaymentPost: async (payReq: string, timeoutSeconds?: number, feeLimitMsat?: number, amountMsat?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payReq' is not null or undefined
            assertParamExists('lightningSendPaymentLightningSendPaymentPost', 'payReq', payReq)
            const localVarPath = `/lightning/send-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (payReq !== undefined) {
                localVarQueryParameter['pay_req'] = payReq;
            }

            if (timeoutSeconds !== undefined) {
                localVarQueryParameter['timeout_seconds'] = timeoutSeconds;
            }

            if (feeLimitMsat !== undefined) {
                localVarQueryParameter['fee_limit_msat'] = feeLimitMsat;
            }

            if (amountMsat !== undefined) {
                localVarQueryParameter['amount_msat'] = amountMsat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlocks a locked wallet.
         * @param {UnlockWalletInput} unlockWalletInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningUnlockWalletLightningUnlockWalletPost: async (unlockWalletInput: UnlockWalletInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'unlockWalletInput' is not null or undefined
            assertParamExists('lightningUnlockWalletLightningUnlockWalletPost', 'unlockWalletInput', unlockWalletInput)
            const localVarPath = `/lightning/unlock-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unlockWalletInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LightningApi - functional programming interface
 * @export
 */
export const LightningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LightningApiAxiosParamCreator(configuration)
    return {
        /**
         * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
         * @summary Addinvoice adds a new Invoice to the database.
         * @param {number} valueMsat 
         * @param {string} [memo] 
         * @param {number} [expiry] 
         * @param {boolean} [isKeysend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningAddInvoiceLightningAddInvoicePost(valueMsat: number, memo?: string, expiry?: number, isKeysend?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningAddInvoiceLightningAddInvoicePost(valueMsat, memo, expiry, isKeysend, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For additional information see [LND docs](https://api.lightning.community/#closechannel)
         * @summary close a channel
         * @param {string} channelId 
         * @param {boolean} forceClose 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningCloseChannelLightningCloseChannelPost(channelId: string, forceClose: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningCloseChannelLightningCloseChannelPost(channelId, forceClose, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
         * @param {string} payReq The payment request string to be decoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningDecodePayReqLightningDecodePayReqGet(payReq: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningDecodePayReqLightningDecodePayReqGet(payReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the current on chain and channel balances of the lighting wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningGetBalanceLightningGetBalanceGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletBalance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningGetBalanceLightningGetBalanceGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Currently, year and total fees are always null. Backends don\'t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
         * @summary Returns the daily, weekly and monthly fee revenue earned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningGetFeeRevenueLightningGetFeeRevenueGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeRevenue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningGetFeeRevenueLightningGetFeeRevenueGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request information about the currently running lightning node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningGetInfoLightningGetInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LnInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningGetInfoLightningGetInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get lightweight current lightning info. Less verbose version of /lightning/get-info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningGetInfoLiteLightningGetInfoLiteGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LightningInfoLite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningGetInfoLiteLightningGetInfoLiteGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
         * @summary Lists all on-chain transactions, payments and invoices in the wallet
         * @param {boolean} [successfulOnly] If set, only successful transaction will be returned in the response.
         * @param {number} [indexOffset] The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response.
         * @param {number} [maxTx] The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null.
         * @param {boolean} [reversed] If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningListAllTxLightningListAllTxGet(successfulOnly?: boolean, indexOffset?: number, maxTx?: number, reversed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenericTx>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningListAllTxLightningListAllTxGet(successfulOnly, indexOffset, maxTx, reversed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of open channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningListChannelsLightningListChannelsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Channel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningListChannelsLightningListChannelsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all invoices from the wallet. Modeled after LND implementation.
         * @param {boolean} [pendingOnly] If set, only invoices that are not settled and not canceled will be returned in the response.
         * @param {number} [indexOffset] The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response.
         * @param {number} [numMaxInvoices] The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null.
         * @param {boolean} [reversed] If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningListInvoicesLightningListInvoicesGet(pendingOnly?: boolean, indexOffset?: number, numMaxInvoices?: number, reversed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningListInvoicesLightningListInvoicesGet(pendingOnly, indexOffset, numMaxInvoices, reversed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all onchain transactions from the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningListOnchainTxLightningListOnchainTxGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OnChainTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningListOnchainTxLightningListOnchainTxGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of all outgoing payments. Modeled after LND implementation.
         * @param {boolean} [includeIncomplete] If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn\&#39;t change the meaning of the indices, which are tied to individual payments.
         * @param {number} [indexOffset] The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards.
         * @param {number} [maxPayments] The maximal number of payments returned in the response to this query.
         * @param {boolean} [reversed] If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningListPaymentsLightningListPaymentsGet(includeIncomplete?: boolean, indexOffset?: number, maxPayments?: number, reversed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningListPaymentsLightningListPaymentsGet(includeIncomplete, indexOffset, maxPayments, reversed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
         * @summary Generate a new on-chain address
         * @param {NewAddressInput} newAddressInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningNewAddressLightningNewAddressPost(newAddressInput: NewAddressInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningNewAddressLightningNewAddressPost(newAddressInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ ==1: interpreted as urgent (aim for next block) * Set _target_conf_ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ >=10: interpreted as slow (next 100 blocks or so)  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
         * @summary open a new lightning channel
         * @param {number} localFundingAmount 
         * @param {string} nodeURI 
         * @param {number} [targetConfs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningOpenChannelLightningOpenChannelPost(localFundingAmount: number, nodeURI: string, targetConfs?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningOpenChannelLightningOpenChannelPost(localFundingAmount, nodeURI, targetConfs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  >  See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ ==1: interpreted as urgent (aim for next block) * Set __target_conf__ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ >=10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
         * @summary Attempt to send on-chain funds.
         * @param {SendCoinsInput} sendCoinsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningSendCoinsLightningSendCoinsPost(sendCoinsInput: SendCoinsInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendCoinsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningSendCoinsLightningSendCoinsPost(sendCoinsInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
         * @summary Attempt to pay a payment request.
         * @param {string} payReq 
         * @param {number} [timeoutSeconds] 
         * @param {number} [feeLimitMsat] 
         * @param {number} [amountMsat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningSendPaymentLightningSendPaymentPost(payReq: string, timeoutSeconds?: number, feeLimitMsat?: number, amountMsat?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningSendPaymentLightningSendPaymentPost(payReq, timeoutSeconds, feeLimitMsat, amountMsat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlocks a locked wallet.
         * @param {UnlockWalletInput} unlockWalletInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lightningUnlockWalletLightningUnlockWalletPost(unlockWalletInput: UnlockWalletInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lightningUnlockWalletLightningUnlockWalletPost(unlockWalletInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LightningApi - factory interface
 * @export
 */
export const LightningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LightningApiFp(configuration)
    return {
        /**
         * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
         * @summary Addinvoice adds a new Invoice to the database.
         * @param {number} valueMsat 
         * @param {string} [memo] 
         * @param {number} [expiry] 
         * @param {boolean} [isKeysend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningAddInvoiceLightningAddInvoicePost(valueMsat: number, memo?: string, expiry?: number, isKeysend?: boolean, options?: any): AxiosPromise<Invoice> {
            return localVarFp.lightningAddInvoiceLightningAddInvoicePost(valueMsat, memo, expiry, isKeysend, options).then((request) => request(axios, basePath));
        },
        /**
         * For additional information see [LND docs](https://api.lightning.community/#closechannel)
         * @summary close a channel
         * @param {string} channelId 
         * @param {boolean} forceClose 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningCloseChannelLightningCloseChannelPost(channelId: string, forceClose: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.lightningCloseChannelLightningCloseChannelPost(channelId, forceClose, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
         * @param {string} payReq The payment request string to be decoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningDecodePayReqLightningDecodePayReqGet(payReq: string, options?: any): AxiosPromise<PaymentRequest> {
            return localVarFp.lightningDecodePayReqLightningDecodePayReqGet(payReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current on chain and channel balances of the lighting wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetBalanceLightningGetBalanceGet(options?: any): AxiosPromise<WalletBalance> {
            return localVarFp.lightningGetBalanceLightningGetBalanceGet(options).then((request) => request(axios, basePath));
        },
        /**
         *  Currently, year and total fees are always null. Backends don\'t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
         * @summary Returns the daily, weekly and monthly fee revenue earned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetFeeRevenueLightningGetFeeRevenueGet(options?: any): AxiosPromise<FeeRevenue> {
            return localVarFp.lightningGetFeeRevenueLightningGetFeeRevenueGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request information about the currently running lightning node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetInfoLightningGetInfoGet(options?: any): AxiosPromise<LnInfo> {
            return localVarFp.lightningGetInfoLightningGetInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get lightweight current lightning info. Less verbose version of /lightning/get-info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningGetInfoLiteLightningGetInfoLiteGet(options?: any): AxiosPromise<LightningInfoLite> {
            return localVarFp.lightningGetInfoLiteLightningGetInfoLiteGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
         * @summary Lists all on-chain transactions, payments and invoices in the wallet
         * @param {boolean} [successfulOnly] If set, only successful transaction will be returned in the response.
         * @param {number} [indexOffset] The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response.
         * @param {number} [maxTx] The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null.
         * @param {boolean} [reversed] If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListAllTxLightningListAllTxGet(successfulOnly?: boolean, indexOffset?: number, maxTx?: number, reversed?: boolean, options?: any): AxiosPromise<Array<GenericTx>> {
            return localVarFp.lightningListAllTxLightningListAllTxGet(successfulOnly, indexOffset, maxTx, reversed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of open channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListChannelsLightningListChannelsGet(options?: any): AxiosPromise<Array<Channel>> {
            return localVarFp.lightningListChannelsLightningListChannelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all invoices from the wallet. Modeled after LND implementation.
         * @param {boolean} [pendingOnly] If set, only invoices that are not settled and not canceled will be returned in the response.
         * @param {number} [indexOffset] The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response.
         * @param {number} [numMaxInvoices] The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null.
         * @param {boolean} [reversed] If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListInvoicesLightningListInvoicesGet(pendingOnly?: boolean, indexOffset?: number, numMaxInvoices?: number, reversed?: boolean, options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.lightningListInvoicesLightningListInvoicesGet(pendingOnly, indexOffset, numMaxInvoices, reversed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all onchain transactions from the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListOnchainTxLightningListOnchainTxGet(options?: any): AxiosPromise<Array<OnChainTransaction>> {
            return localVarFp.lightningListOnchainTxLightningListOnchainTxGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all outgoing payments. Modeled after LND implementation.
         * @param {boolean} [includeIncomplete] If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn\&#39;t change the meaning of the indices, which are tied to individual payments.
         * @param {number} [indexOffset] The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards.
         * @param {number} [maxPayments] The maximal number of payments returned in the response to this query.
         * @param {boolean} [reversed] If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningListPaymentsLightningListPaymentsGet(includeIncomplete?: boolean, indexOffset?: number, maxPayments?: number, reversed?: boolean, options?: any): AxiosPromise<Array<Payment>> {
            return localVarFp.lightningListPaymentsLightningListPaymentsGet(includeIncomplete, indexOffset, maxPayments, reversed, options).then((request) => request(axios, basePath));
        },
        /**
         *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
         * @summary Generate a new on-chain address
         * @param {NewAddressInput} newAddressInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningNewAddressLightningNewAddressPost(newAddressInput: NewAddressInput, options?: any): AxiosPromise<string> {
            return localVarFp.lightningNewAddressLightningNewAddressPost(newAddressInput, options).then((request) => request(axios, basePath));
        },
        /**
         *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ ==1: interpreted as urgent (aim for next block) * Set _target_conf_ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ >=10: interpreted as slow (next 100 blocks or so)  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
         * @summary open a new lightning channel
         * @param {number} localFundingAmount 
         * @param {string} nodeURI 
         * @param {number} [targetConfs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningOpenChannelLightningOpenChannelPost(localFundingAmount: number, nodeURI: string, targetConfs?: number, options?: any): AxiosPromise<string> {
            return localVarFp.lightningOpenChannelLightningOpenChannelPost(localFundingAmount, nodeURI, targetConfs, options).then((request) => request(axios, basePath));
        },
        /**
         *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  >  See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ ==1: interpreted as urgent (aim for next block) * Set __target_conf__ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ >=10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
         * @summary Attempt to send on-chain funds.
         * @param {SendCoinsInput} sendCoinsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningSendCoinsLightningSendCoinsPost(sendCoinsInput: SendCoinsInput, options?: any): AxiosPromise<SendCoinsResponse> {
            return localVarFp.lightningSendCoinsLightningSendCoinsPost(sendCoinsInput, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
         * @summary Attempt to pay a payment request.
         * @param {string} payReq 
         * @param {number} [timeoutSeconds] 
         * @param {number} [feeLimitMsat] 
         * @param {number} [amountMsat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningSendPaymentLightningSendPaymentPost(payReq: string, timeoutSeconds?: number, feeLimitMsat?: number, amountMsat?: number, options?: any): AxiosPromise<Payment> {
            return localVarFp.lightningSendPaymentLightningSendPaymentPost(payReq, timeoutSeconds, feeLimitMsat, amountMsat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlocks a locked wallet.
         * @param {UnlockWalletInput} unlockWalletInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lightningUnlockWalletLightningUnlockWalletPost(unlockWalletInput: UnlockWalletInput, options?: any): AxiosPromise<boolean> {
            return localVarFp.lightningUnlockWalletLightningUnlockWalletPost(unlockWalletInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LightningApi - object-oriented interface
 * @export
 * @class LightningApi
 * @extends {BaseAPI}
 */
export class LightningApi extends BaseAPI {
    /**
     * For additional information see [LND docs](https://api.lightning.community/#addinvoice)
     * @summary Addinvoice adds a new Invoice to the database.
     * @param {number} valueMsat 
     * @param {string} [memo] 
     * @param {number} [expiry] 
     * @param {boolean} [isKeysend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningAddInvoiceLightningAddInvoicePost(valueMsat: number, memo?: string, expiry?: number, isKeysend?: boolean, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningAddInvoiceLightningAddInvoicePost(valueMsat, memo, expiry, isKeysend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For additional information see [LND docs](https://api.lightning.community/#closechannel)
     * @summary close a channel
     * @param {string} channelId 
     * @param {boolean} forceClose 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningCloseChannelLightningCloseChannelPost(channelId: string, forceClose: boolean, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningCloseChannelLightningCloseChannelPost(channelId, forceClose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
     * @param {string} payReq The payment request string to be decoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningDecodePayReqLightningDecodePayReqGet(payReq: string, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningDecodePayReqLightningDecodePayReqGet(payReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current on chain and channel balances of the lighting wallet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningGetBalanceLightningGetBalanceGet(options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningGetBalanceLightningGetBalanceGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Currently, year and total fees are always null. Backends don\'t return these values by default. Implementation in BlitzAPI is a [to-do](https://github.com/fusion44/blitz_api/issues/64).     
     * @summary Returns the daily, weekly and monthly fee revenue earned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningGetFeeRevenueLightningGetFeeRevenueGet(options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningGetFeeRevenueLightningGetFeeRevenueGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request information about the currently running lightning node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningGetInfoLightningGetInfoGet(options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningGetInfoLightningGetInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get lightweight current lightning info. Less verbose version of /lightning/get-info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningGetInfoLiteLightningGetInfoLiteGet(options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningGetInfoLiteLightningGetInfoLiteGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list with all on-chain transaction, payments and invoices combined into one list.     The index of each tx is only valid for each identical set of parameters.     
     * @summary Lists all on-chain transactions, payments and invoices in the wallet
     * @param {boolean} [successfulOnly] If set, only successful transaction will be returned in the response.
     * @param {number} [indexOffset] The index of an transaction that will be used as either the start or end of a query to determine which invoices should be returned in the response.
     * @param {number} [maxTx] The max number of transaction to return in the response to this query. Will return all transactions when set to 0 or null.
     * @param {boolean} [reversed] If set, the transactions returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningListAllTxLightningListAllTxGet(successfulOnly?: boolean, indexOffset?: number, maxTx?: number, reversed?: boolean, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningListAllTxLightningListAllTxGet(successfulOnly, indexOffset, maxTx, reversed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of open channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningListChannelsLightningListChannelsGet(options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningListChannelsLightningListChannelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all invoices from the wallet. Modeled after LND implementation.
     * @param {boolean} [pendingOnly] If set, only invoices that are not settled and not canceled will be returned in the response.
     * @param {number} [indexOffset] The index of an invoice that will be used as either the start or end of a query to determine which invoices should be returned in the response.
     * @param {number} [numMaxInvoices] The max number of invoices to return in the response to this query. Will return all invoices when set to 0 or null.
     * @param {boolean} [reversed] If set, the invoices returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningListInvoicesLightningListInvoicesGet(pendingOnly?: boolean, indexOffset?: number, numMaxInvoices?: number, reversed?: boolean, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningListInvoicesLightningListInvoicesGet(pendingOnly, indexOffset, numMaxInvoices, reversed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all onchain transactions from the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningListOnchainTxLightningListOnchainTxGet(options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningListOnchainTxLightningListOnchainTxGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all outgoing payments. Modeled after LND implementation.
     * @param {boolean} [includeIncomplete] If true, then return payments that have not yet fully completed. This means that pending payments, as well as failed payments will show up if this field is set to true. This flag doesn\&#39;t change the meaning of the indices, which are tied to individual payments.
     * @param {number} [indexOffset] The index of a payment that will be used as either the start or end of a query to determine which payments should be returned in the response. The index_offset is exclusive. In the case of a zero index_offset, the query will start with the oldest payment when paginating forwards, or will end with the most recent payment when paginating backwards.
     * @param {number} [maxPayments] The maximal number of payments returned in the response to this query.
     * @param {boolean} [reversed] If set, the payments returned will result from seeking backwards from the specified index offset. This can be used to paginate backwards. The order of the returned payments is always oldest first (ascending index order).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningListPaymentsLightningListPaymentsGet(includeIncomplete?: boolean, indexOffset?: number, maxPayments?: number, reversed?: boolean, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningListPaymentsLightningListPaymentsGet(includeIncomplete, indexOffset, maxPayments, reversed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Generate a wallet new address. Address-types has to be one of: * **p2wkh**:  Pay to witness key hash (bech32) * **np2wkh**: Pay to nested witness key hash     
     * @summary Generate a new on-chain address
     * @param {NewAddressInput} newAddressInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningNewAddressLightningNewAddressPost(newAddressInput: NewAddressInput, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningNewAddressLightningNewAddressPost(newAddressInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  __open-channel__ attempts to open a channel with a peer.  ### LND: _target_conf_: The target number of blocks that the funding transaction should be confirmed by.  ### c-lightning: * Set _target_conf_ ==1: interpreted as urgent (aim for next block) * Set _target_conf_ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set _target_cont_ >=10: interpreted as slow (next 100 blocks or so)  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * @summary open a new lightning channel
     * @param {number} localFundingAmount 
     * @param {string} nodeURI 
     * @param {number} [targetConfs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningOpenChannelLightningOpenChannelPost(localFundingAmount: number, nodeURI: string, targetConfs?: number, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningOpenChannelLightningOpenChannelPost(localFundingAmount, nodeURI, targetConfs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  __send-coins__ executes a request to send coins to a particular address.  ### LND: If neither __target_conf__, or __sat_per_vbyte__ are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.  >  See [https://api.lightning.community/?shell#sendcoins](https://api.lightning.community/?shell#sendcoins)  ### c-lightning: * Set __target_conf__ ==1: interpreted as urgent (aim for next block) * Set __target_conf__ >=2: interpreted as normal (next 4 blocks or so, **default**) * Set __target_cont__ >=10: interpreted as slow (next 100 blocks or so) * If __sat_per_vbyte__ is set then __target_conf__ is ignored and vbytes (sipabytes) will be used.  >  See [https://lightning.readthedocs.io/lightning-txprepare.7.html](https://lightning.readthedocs.io/lightning-txprepare.7.html) 
     * @summary Attempt to send on-chain funds.
     * @param {SendCoinsInput} sendCoinsInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningSendCoinsLightningSendCoinsPost(sendCoinsInput: SendCoinsInput, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningSendCoinsLightningSendCoinsPost(sendCoinsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints attempts to pay a payment request.  Intermediate status updates will be sent via the SSE channel. This endpoint returns the last success or error message from the node. 
     * @summary Attempt to pay a payment request.
     * @param {string} payReq 
     * @param {number} [timeoutSeconds] 
     * @param {number} [feeLimitMsat] 
     * @param {number} [amountMsat] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningSendPaymentLightningSendPaymentPost(payReq: string, timeoutSeconds?: number, feeLimitMsat?: number, amountMsat?: number, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningSendPaymentLightningSendPaymentPost(payReq, timeoutSeconds, feeLimitMsat, amountMsat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlocks a locked wallet.
     * @param {UnlockWalletInput} unlockWalletInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public lightningUnlockWalletLightningUnlockWalletPost(unlockWalletInput: UnlockWalletInput, options?: AxiosRequestConfig) {
        return LightningApiFp(this.configuration).lightningUnlockWalletLightningUnlockWalletPost(unlockWalletInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetupApi - axios parameter creator
 * @export
 */
export const SetupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Shutdown
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShutdownSetupShutdownGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setup/shutdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusSetupStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setup/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setup Final Done
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupFinalDoneSetupSetupFinalDonePost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setup/setup-final-done`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setup Final Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupFinalInfoSetupSetupFinalInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setup/setup-final-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setup Start Done
         * @param {StartDoneData} startDoneData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupStartDoneSetupSetupStartDonePost: async (startDoneData: StartDoneData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDoneData' is not null or undefined
            assertParamExists('setupStartDoneSetupSetupStartDonePost', 'startDoneData', startDoneData)
            const localVarPath = `/setup/setup-start-done`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startDoneData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setup Start Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupStartInfoSetupSetupStartInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setup/setup-start-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setup Sync Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupSyncInfoSetupSetupSyncInfoPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setup/setup-sync-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupApi - functional programming interface
 * @export
 */
export const SetupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Shutdown
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShutdownSetupShutdownGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShutdownSetupShutdownGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusSetupStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusSetupStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Setup Final Done
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupFinalDoneSetupSetupFinalDonePost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupFinalDoneSetupSetupFinalDonePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Setup Final Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupFinalInfoSetupSetupFinalInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupFinalInfoSetupSetupFinalInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Setup Start Done
         * @param {StartDoneData} startDoneData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupStartDoneSetupSetupStartDonePost(startDoneData: StartDoneData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupStartDoneSetupSetupStartDonePost(startDoneData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Setup Start Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupStartInfoSetupSetupStartInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupStartInfoSetupSetupStartInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Setup Sync Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupSyncInfoSetupSetupSyncInfoPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupSyncInfoSetupSetupSyncInfoPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetupApi - factory interface
 * @export
 */
export const SetupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetupApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Shutdown
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShutdownSetupShutdownGet(options?: any): AxiosPromise<any> {
            return localVarFp.getShutdownSetupShutdownGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusSetupStatusGet(options?: any): AxiosPromise<any> {
            return localVarFp.getStatusSetupStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setup Final Done
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupFinalDoneSetupSetupFinalDonePost(options?: any): AxiosPromise<any> {
            return localVarFp.setupFinalDoneSetupSetupFinalDonePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setup Final Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupFinalInfoSetupSetupFinalInfoGet(options?: any): AxiosPromise<any> {
            return localVarFp.setupFinalInfoSetupSetupFinalInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setup Start Done
         * @param {StartDoneData} startDoneData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupStartDoneSetupSetupStartDonePost(startDoneData: StartDoneData, options?: any): AxiosPromise<any> {
            return localVarFp.setupStartDoneSetupSetupStartDonePost(startDoneData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setup Start Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupStartInfoSetupSetupStartInfoGet(options?: any): AxiosPromise<any> {
            return localVarFp.setupStartInfoSetupSetupStartInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setup Sync Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupSyncInfoSetupSetupSyncInfoPost(options?: any): AxiosPromise<any> {
            return localVarFp.setupSyncInfoSetupSetupSyncInfoPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SetupApi - object-oriented interface
 * @export
 * @class SetupApi
 * @extends {BaseAPI}
 */
export class SetupApi extends BaseAPI {
    /**
     * 
     * @summary Get Shutdown
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public getShutdownSetupShutdownGet(options?: AxiosRequestConfig) {
        return SetupApiFp(this.configuration).getShutdownSetupShutdownGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public getStatusSetupStatusGet(options?: AxiosRequestConfig) {
        return SetupApiFp(this.configuration).getStatusSetupStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Setup Final Done
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupFinalDoneSetupSetupFinalDonePost(options?: AxiosRequestConfig) {
        return SetupApiFp(this.configuration).setupFinalDoneSetupSetupFinalDonePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Setup Final Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupFinalInfoSetupSetupFinalInfoGet(options?: AxiosRequestConfig) {
        return SetupApiFp(this.configuration).setupFinalInfoSetupSetupFinalInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Setup Start Done
     * @param {StartDoneData} startDoneData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupStartDoneSetupSetupStartDonePost(startDoneData: StartDoneData, options?: AxiosRequestConfig) {
        return SetupApiFp(this.configuration).setupStartDoneSetupSetupStartDonePost(startDoneData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Setup Start Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupStartInfoSetupSetupStartInfoGet(options?: AxiosRequestConfig) {
        return SetupApiFp(this.configuration).setupStartInfoSetupSetupStartInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Setup Sync Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupSyncInfoSetupSetupSyncInfoPost(options?: AxiosRequestConfig) {
        return SetupApiFp(this.configuration).setupSyncInfoSetupSetupSyncInfoPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Endpoint to change your password a, b or c
         * @param {string} type 
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemChangePasswordSystemChangePasswordPost: async (type: string, oldPassword: string, newPassword: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('systemChangePasswordSystemChangePasswordPost', 'type', type)
            // verify required parameter 'oldPassword' is not null or undefined
            assertParamExists('systemChangePasswordSystemChangePasswordPost', 'oldPassword', oldPassword)
            // verify required parameter 'newPassword' is not null or undefined
            assertParamExists('systemChangePasswordSystemChangePasswordPost', 'newPassword', newPassword)
            const localVarPath = `/system/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (oldPassword !== undefined) {
                localVarQueryParameter['old_password'] = oldPassword;
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['new_password'] = newPassword;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get credential information to connect external apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemConnectionInfoSystemConnectionInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/connection-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint will gather latest system logs and return it in a raw string. This endpoint will **not** return immediately because it gathers all data on time of the request. 
         * @summary Get raw system logs as a text string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGetDebugLogsRawSystemGetDebugLogsRawGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/get-debug-logs-raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get system status information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGetSystemInfoSystemGetSystemInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/get-system-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe to hardware status information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemHardwareInfoSubSystemHardwareInfoSubGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/hardware-info-sub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hardware status information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemHardwareInfoSystemHardwareInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/hardware-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs the user in with the current password
         * @param {LoginInput} loginInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemLoginSystemLoginPost: async (loginInput: LoginInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInput' is not null or undefined
            assertParamExists('systemLoginSystemLoginPost', 'loginInput', loginInput)
            const localVarPath = `/system/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to reboot the system.     Will send a `system_reboot_initiated` SSE message immediately to     all connected clients.     
         * @summary Reboots the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRebootSystemRebootPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/reboot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Endpoint to refresh an authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRefreshTokenSystemRefreshTokenPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to shutdown the system.     Will send a `system_shutdown_initiated` SSE message immediately to all     connected clients.     
         * @summary Shuts the system down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemShutdownSystemShutdownPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/shutdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Endpoint to change your password a, b or c
         * @param {string} type 
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemChangePasswordSystemChangePasswordPost(type: string, oldPassword: string, newPassword: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemChangePasswordSystemChangePasswordPost(type, oldPassword, newPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get credential information to connect external apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemConnectionInfoSystemConnectionInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemConnectionInfoSystemConnectionInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  This endpoint will gather latest system logs and return it in a raw string. This endpoint will **not** return immediately because it gathers all data on time of the request. 
         * @summary Get raw system logs as a text string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGetDebugLogsRawSystemGetDebugLogsRawGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawDebugLogData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGetDebugLogsRawSystemGetDebugLogsRawGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get system status information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGetSystemInfoSystemGetSystemInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGetSystemInfoSystemGetSystemInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Subscribe to hardware status information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemHardwareInfoSubSystemHardwareInfoSubGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemHardwareInfoSubSystemHardwareInfoSubGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get hardware status information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemHardwareInfoSystemHardwareInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemHardwareInfoSystemHardwareInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs the user in with the current password
         * @param {LoginInput} loginInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemLoginSystemLoginPost(loginInput: LoginInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemLoginSystemLoginPost(loginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempts to reboot the system.     Will send a `system_reboot_initiated` SSE message immediately to     all connected clients.     
         * @summary Reboots the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemRebootSystemRebootPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemRebootSystemRebootPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Endpoint to refresh an authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemRefreshTokenSystemRefreshTokenPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemRefreshTokenSystemRefreshTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempts to shutdown the system.     Will send a `system_shutdown_initiated` SSE message immediately to all     connected clients.     
         * @summary Shuts the system down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemShutdownSystemShutdownPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemShutdownSystemShutdownPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * 
         * @summary Endpoint to change your password a, b or c
         * @param {string} type 
         * @param {string} oldPassword 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemChangePasswordSystemChangePasswordPost(type: string, oldPassword: string, newPassword: string, options?: any): AxiosPromise<any> {
            return localVarFp.systemChangePasswordSystemChangePasswordPost(type, oldPassword, newPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get credential information to connect external apps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemConnectionInfoSystemConnectionInfoGet(options?: any): AxiosPromise<ConnectionInfo> {
            return localVarFp.systemConnectionInfoSystemConnectionInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint will gather latest system logs and return it in a raw string. This endpoint will **not** return immediately because it gathers all data on time of the request. 
         * @summary Get raw system logs as a text string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGetDebugLogsRawSystemGetDebugLogsRawGet(options?: any): AxiosPromise<RawDebugLogData> {
            return localVarFp.systemGetDebugLogsRawSystemGetDebugLogsRawGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get system status information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGetSystemInfoSystemGetSystemInfoGet(options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.systemGetSystemInfoSystemGetSystemInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Subscribe to hardware status information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemHardwareInfoSubSystemHardwareInfoSubGet(options?: any): AxiosPromise<any> {
            return localVarFp.systemHardwareInfoSubSystemHardwareInfoSubGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get hardware status information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemHardwareInfoSystemHardwareInfoGet(options?: any): AxiosPromise<any> {
            return localVarFp.systemHardwareInfoSystemHardwareInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs the user in with the current password
         * @param {LoginInput} loginInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemLoginSystemLoginPost(loginInput: LoginInput, options?: any): AxiosPromise<any> {
            return localVarFp.systemLoginSystemLoginPost(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to reboot the system.     Will send a `system_reboot_initiated` SSE message immediately to     all connected clients.     
         * @summary Reboots the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRebootSystemRebootPost(options?: any): AxiosPromise<any> {
            return localVarFp.systemRebootSystemRebootPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Endpoint to refresh an authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRefreshTokenSystemRefreshTokenPost(options?: any): AxiosPromise<any> {
            return localVarFp.systemRefreshTokenSystemRefreshTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to shutdown the system.     Will send a `system_shutdown_initiated` SSE message immediately to all     connected clients.     
         * @summary Shuts the system down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemShutdownSystemShutdownPost(options?: any): AxiosPromise<any> {
            return localVarFp.systemShutdownSystemShutdownPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @summary Endpoint to change your password a, b or c
     * @param {string} type 
     * @param {string} oldPassword 
     * @param {string} newPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemChangePasswordSystemChangePasswordPost(type: string, oldPassword: string, newPassword: string, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemChangePasswordSystemChangePasswordPost(type, oldPassword, newPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get credential information to connect external apps.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemConnectionInfoSystemConnectionInfoGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemConnectionInfoSystemConnectionInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint will gather latest system logs and return it in a raw string. This endpoint will **not** return immediately because it gathers all data on time of the request. 
     * @summary Get raw system logs as a text string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGetDebugLogsRawSystemGetDebugLogsRawGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGetDebugLogsRawSystemGetDebugLogsRawGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get system status information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGetSystemInfoSystemGetSystemInfoGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGetSystemInfoSystemGetSystemInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Subscribe to hardware status information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemHardwareInfoSubSystemHardwareInfoSubGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemHardwareInfoSubSystemHardwareInfoSubGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get hardware status information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemHardwareInfoSystemHardwareInfoGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemHardwareInfoSystemHardwareInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs the user in with the current password
     * @param {LoginInput} loginInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemLoginSystemLoginPost(loginInput: LoginInput, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemLoginSystemLoginPost(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to reboot the system.     Will send a `system_reboot_initiated` SSE message immediately to     all connected clients.     
     * @summary Reboots the system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemRebootSystemRebootPost(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemRebootSystemRebootPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Endpoint to refresh an authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemRefreshTokenSystemRefreshTokenPost(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemRefreshTokenSystemRefreshTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to shutdown the system.     Will send a `system_shutdown_initiated` SSE message immediately to all     connected clients.     
     * @summary Shuts the system down
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemShutdownSystemShutdownPost(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemShutdownSystemShutdownPost(options).then((request) => request(this.axios, this.basePath));
    }
}


